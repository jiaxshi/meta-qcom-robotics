# This patch file is from Qualcomm Innovation Center, Inc. and is provided under the following license:
# Copyright (c) 2025 Qualcomm Innovation Center, Inc. All rights reserved.
# SPDX-License-Identifier: BSD-3-Clause-Clear
From 773be9a2ebabdc86c854a92ca5a7fb4a00a5cff6 Mon Sep 17 00:00:00 2001
From: xkuo <quic_xkuo@quicinc.com>
Date: Thu, 17 Apr 2025 16:43:29 +0800
Subject: [PATCH] Fix compilation errors and add our feature

Signed-off-by: xiaohui kuo <quic_xkuo@quicinc.com>
---
 CMakeLists.txt                                |  16 ++-
 .../cloud/internal/map_builder_server.h       |   4 +-
 cartographer/common/internal/blocking_queue.h |  20 +--
 .../testing/thread_pool_for_testing.cc        |   4 +-
 .../testing/thread_pool_for_testing.h         |  14 +-
 cartographer/common/task.h                    |  20 +--
 cartographer/common/thread_pool.cc            |   2 +-
 cartographer/common/thread_pool.h             |  12 +-
 cartographer/common/thread_pool_test.cc       |   4 +-
 .../2d/local_trajectory_builder_2d.cc         |   3 +-
 .../mapping/internal/2d/pose_graph_2d.cc      | 136 +++++++++++++++---
 .../mapping/internal/2d/pose_graph_2d.h       | 118 ++++++++-------
 .../mapping/internal/3d/pose_graph_3d.cc      |  54 ++++---
 .../mapping/internal/3d/pose_graph_3d.h       | 118 ++++++++-------
 .../mapping/internal/connected_components.h   |  20 +--
 .../constraints/constraint_builder_2d.cc      |   4 +-
 .../constraints/constraint_builder_2d.h       |  22 +--
 .../constraints/constraint_builder_3d.cc      |   4 +-
 .../constraints/constraint_builder_3d.h       |  26 ++--
 cartographer/mapping/map_builder.cc           |  39 ++++-
 cartographer/mapping/map_builder.h            |  14 +-
 cartographer/mapping/map_builder_interface.h  |  14 +-
 cartographer/mapping/pose_graph.h             |   3 +
 cartographer/mapping/pose_graph_interface.h   |   7 +-
 cartographer/transform/rigid_transform.h      |   6 +
 cmake/functions.cmake                         |   1 -
 cmake/modules/FindGMock.cmake                 |  10 +-
 cmake/modules/FindLuaGoogle.cmake             |   4 +-
 28 files changed, 453 insertions(+), 246 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 7a80f16..05f489b 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -27,6 +27,7 @@ option(BUILD_PROMETHEUS "build Prometheus monitoring support" false)
 
 include("${PROJECT_SOURCE_DIR}/cmake/functions.cmake")
 google_initialize_cartographer_project()
+
 google_enable_testing()
 
 find_package(absl REQUIRED)
@@ -36,6 +37,8 @@ if(WIN32)
   set(Boost_USE_STATIC_LIBS FALSE)
 endif()
 find_package(Boost REQUIRED COMPONENTS ${BOOST_COMPONENTS})
+set(CMAKE_CXX_STANDARD 17)
+set(CMAKE_CXX_EXTENSIONS 17)
 find_package(Ceres REQUIRED COMPONENTS SuiteSparse)
 find_package(Eigen3 REQUIRED)
 find_package(Lua REQUIRED)
@@ -63,10 +66,10 @@ else()
 endif()
 
 # Only build the documentation if we can find Sphinx.
-find_package(Sphinx)
-if(SPHINX_FOUND)
-  add_subdirectory("docs")
-endif()
+# find_package(Sphinx)
+#if(SPHINX_FOUND)
+#  add_subdirectory("docs")
+#endif()
 
 # Install catkin package.xml
 install(FILES package.xml DESTINATION share/cartographer)
@@ -199,6 +202,7 @@ google_binary(cartographer_compute_relations_metrics
   SRCS
     cartographer/ground_truth/compute_relations_metrics_main.cc
 )
+target_link_libraries(cartographer_compute_relations_metrics PUBLIC -ldl)
 
 google_binary(cartographer_pbstream
   SRCS
@@ -294,7 +298,7 @@ if(${BUILD_PROMETHEUS})
   target_compile_definitions(${PROJECT_NAME} PUBLIC USE_PROMETHEUS=1)
 endif()
 
-set(TARGET_COMPILE_FLAGS "${TARGET_COMPILE_FLAGS} ${GOOG_CXX_FLAGS}")
+set(TARGET_COMPILE_FLAGS "${TARGET_COMPILE_FLAGS} ${GOOG_CXX_FLAGS} ${CERES_CXX_FLAGS}")
 set_target_properties(${PROJECT_NAME} PROPERTIES
   COMPILE_FLAGS ${TARGET_COMPILE_FLAGS})
 
@@ -329,7 +333,7 @@ foreach(ABS_FIL ${ALL_TESTS})
     target_link_libraries("${TEST_TARGET_NAME}" PUBLIC prometheus-cpp-core)
     target_link_libraries("${TEST_TARGET_NAME}" PUBLIC prometheus-cpp-pull)
   endif()
-  target_link_libraries("${TEST_TARGET_NAME}" PUBLIC ${TEST_LIB})
+  target_link_libraries("${TEST_TARGET_NAME}" PUBLIC ${TEST_LIB} -ldl)
 endforeach()
 
 # Add the binary directory first, so that port.h is included after it has
diff --git a/cartographer/cloud/internal/map_builder_server.h b/cartographer/cloud/internal/map_builder_server.h
index 03a70aa..3687f3d 100644
--- a/cartographer/cloud/internal/map_builder_server.h
+++ b/cartographer/cloud/internal/map_builder_server.h
@@ -137,10 +137,10 @@ class MapBuilderServer : public MapBuilderServerInterface {
   absl::Mutex subscriptions_lock_;
   int current_subscription_index_ = 0;
   std::map<int /* trajectory ID */, LocalSlamResultHandlerSubscriptions>
-      local_slam_subscriptions_ GUARDED_BY(subscriptions_lock_);
+      local_slam_subscriptions_ ABSL_GUARDED_BY(subscriptions_lock_);
   std::map<int /* subscription_index */,
            MapBuilderContextInterface::GlobalSlamOptimizationCallback>
-      global_slam_subscriptions_ GUARDED_BY(subscriptions_lock_);
+      global_slam_subscriptions_ ABSL_GUARDED_BY(subscriptions_lock_);
   std::unique_ptr<LocalTrajectoryUploaderInterface> local_trajectory_uploader_;
   int starting_submap_index_ = 0;
 };
diff --git a/cartographer/common/internal/blocking_queue.h b/cartographer/common/internal/blocking_queue.h
index cba91c0..7e3a787 100644
--- a/cartographer/common/internal/blocking_queue.h
+++ b/cartographer/common/internal/blocking_queue.h
@@ -47,7 +47,7 @@ class BlockingQueue {
 
   // Pushes a value onto the queue. Blocks if the queue is full.
   void Push(T t) {
-    const auto predicate = [this]() EXCLUSIVE_LOCKS_REQUIRED(mutex_) {
+    const auto predicate = [this]() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_) {
       return QueueNotFullCondition();
     };
     absl::MutexLock lock(&mutex_);
@@ -57,7 +57,7 @@ class BlockingQueue {
 
   // Like push, but returns false if 'timeout' is reached.
   bool PushWithTimeout(T t, const common::Duration timeout) {
-    const auto predicate = [this]() EXCLUSIVE_LOCKS_REQUIRED(mutex_) {
+    const auto predicate = [this]() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_) {
       return QueueNotFullCondition();
     };
     absl::MutexLock lock(&mutex_);
@@ -71,7 +71,7 @@ class BlockingQueue {
 
   // Pops the next value from the queue. Blocks until a value is available.
   T Pop() {
-    const auto predicate = [this]() EXCLUSIVE_LOCKS_REQUIRED(mutex_) {
+    const auto predicate = [this]() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_) {
       return !QueueEmptyCondition();
     };
     absl::MutexLock lock(&mutex_);
@@ -84,7 +84,7 @@ class BlockingQueue {
 
   // Like Pop, but can timeout. Returns nullptr in this case.
   T PopWithTimeout(const common::Duration timeout) {
-    const auto predicate = [this]() EXCLUSIVE_LOCKS_REQUIRED(mutex_) {
+    const auto predicate = [this]() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_) {
       return !QueueEmptyCondition();
     };
     absl::MutexLock lock(&mutex_);
@@ -100,7 +100,7 @@ class BlockingQueue {
   // Like Peek, but can timeout. Returns nullptr in this case.
   template <typename R>
   R* PeekWithTimeout(const common::Duration timeout) {
-    const auto predicate = [this]() EXCLUSIVE_LOCKS_REQUIRED(mutex_) {
+    const auto predicate = [this]() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_) {
       return !QueueEmptyCondition();
     };
     absl::MutexLock lock(&mutex_);
@@ -131,7 +131,7 @@ class BlockingQueue {
 
   // Blocks until the queue is empty.
   void WaitUntilEmpty() {
-    const auto predicate = [this]() EXCLUSIVE_LOCKS_REQUIRED(mutex_) {
+    const auto predicate = [this]() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_) {
       return QueueEmptyCondition();
     };
     absl::MutexLock lock(&mutex_);
@@ -140,18 +140,18 @@ class BlockingQueue {
 
  private:
   // Returns true iff the queue is empty.
-  bool QueueEmptyCondition() EXCLUSIVE_LOCKS_REQUIRED(mutex_) {
+  bool QueueEmptyCondition() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_) {
     return deque_.empty();
   }
 
   // Returns true iff the queue is not full.
-  bool QueueNotFullCondition() EXCLUSIVE_LOCKS_REQUIRED(mutex_) {
+  bool QueueNotFullCondition() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_) {
     return queue_size_ == kInfiniteQueueSize || deque_.size() < queue_size_;
   }
 
   absl::Mutex mutex_;
-  const size_t queue_size_ GUARDED_BY(mutex_);
-  std::deque<T> deque_ GUARDED_BY(mutex_);
+  const size_t queue_size_ ABSL_GUARDED_BY(mutex_);
+  std::deque<T> deque_ ABSL_GUARDED_BY(mutex_);
 };
 
 }  // namespace common
diff --git a/cartographer/common/internal/testing/thread_pool_for_testing.cc b/cartographer/common/internal/testing/thread_pool_for_testing.cc
index 89744ba..a4d540b 100644
--- a/cartographer/common/internal/testing/thread_pool_for_testing.cc
+++ b/cartographer/common/internal/testing/thread_pool_for_testing.cc
@@ -72,7 +72,7 @@ std::weak_ptr<Task> ThreadPoolForTesting::Schedule(std::unique_ptr<Task> task) {
 
 void ThreadPoolForTesting::WaitUntilIdle() {
   const auto predicate = [this]()
-                             EXCLUSIVE_LOCKS_REQUIRED(mutex_) { return idle_; };
+                             ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_) { return idle_; };
   for (;;) {
     {
       absl::MutexLock locker(&mutex_);
@@ -85,7 +85,7 @@ void ThreadPoolForTesting::WaitUntilIdle() {
 }
 
 void ThreadPoolForTesting::DoWork() {
-  const auto predicate = [this]() EXCLUSIVE_LOCKS_REQUIRED(mutex_) {
+  const auto predicate = [this]() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_) {
     return !task_queue_.empty() || !running_;
   };
   for (;;) {
diff --git a/cartographer/common/internal/testing/thread_pool_for_testing.h b/cartographer/common/internal/testing/thread_pool_for_testing.h
index f733d0f..9a10dfd 100644
--- a/cartographer/common/internal/testing/thread_pool_for_testing.h
+++ b/cartographer/common/internal/testing/thread_pool_for_testing.h
@@ -35,7 +35,7 @@ class ThreadPoolForTesting : public ThreadPoolInterface {
   ~ThreadPoolForTesting();
 
   std::weak_ptr<Task> Schedule(std::unique_ptr<Task> task)
-      LOCKS_EXCLUDED(mutex_) override;
+      ABSL_LOCKS_EXCLUDED(mutex_) override;
 
   void WaitUntilIdle();
 
@@ -44,14 +44,14 @@ class ThreadPoolForTesting : public ThreadPoolInterface {
 
   void DoWork();
 
-  void NotifyDependenciesCompleted(Task* task) LOCKS_EXCLUDED(mutex_) override;
+  void NotifyDependenciesCompleted(Task* task) ABSL_LOCKS_EXCLUDED(mutex_) override;
 
   absl::Mutex mutex_;
-  bool running_ GUARDED_BY(mutex_) = true;
-  bool idle_ GUARDED_BY(mutex_) = true;
-  std::deque<std::shared_ptr<Task>> task_queue_ GUARDED_BY(mutex_);
-  std::map<Task*, std::shared_ptr<Task>> tasks_not_ready_ GUARDED_BY(mutex_);
-  std::thread thread_ GUARDED_BY(mutex_);
+  bool running_ ABSL_GUARDED_BY(mutex_) = true;
+  bool idle_ ABSL_GUARDED_BY(mutex_) = true;
+  std::deque<std::shared_ptr<Task>> task_queue_ ABSL_GUARDED_BY(mutex_);
+  std::map<Task*, std::shared_ptr<Task>> tasks_not_ready_ ABSL_GUARDED_BY(mutex_);
+  std::thread thread_ ABSL_GUARDED_BY(mutex_);
 };
 
 }  // namespace testing
diff --git a/cartographer/common/task.h b/cartographer/common/task.h
index ae44fb1..4256225 100644
--- a/cartographer/common/task.h
+++ b/cartographer/common/task.h
@@ -38,34 +38,34 @@ class Task {
   Task() = default;
   ~Task();
 
-  State GetState() LOCKS_EXCLUDED(mutex_);
+  State GetState() ABSL_LOCKS_EXCLUDED(mutex_);
 
   // State must be 'NEW'.
-  void SetWorkItem(const WorkItem& work_item) LOCKS_EXCLUDED(mutex_);
+  void SetWorkItem(const WorkItem& work_item) ABSL_LOCKS_EXCLUDED(mutex_);
 
   // State must be 'NEW'. 'dependency' may be nullptr, in which case it is
   // assumed completed.
-  void AddDependency(std::weak_ptr<Task> dependency) LOCKS_EXCLUDED(mutex_);
+  void AddDependency(std::weak_ptr<Task> dependency) ABSL_LOCKS_EXCLUDED(mutex_);
 
  private:
   // Allowed in all states.
   void AddDependentTask(Task* dependent_task);
 
   // State must be 'DEPENDENCIES_COMPLETED' and becomes 'COMPLETED'.
-  void Execute() LOCKS_EXCLUDED(mutex_);
+  void Execute() ABSL_LOCKS_EXCLUDED(mutex_);
 
   // State must be 'NEW' and becomes 'DISPATCHED' or 'DEPENDENCIES_COMPLETED'.
-  void SetThreadPool(ThreadPoolInterface* thread_pool) LOCKS_EXCLUDED(mutex_);
+  void SetThreadPool(ThreadPoolInterface* thread_pool) ABSL_LOCKS_EXCLUDED(mutex_);
 
   // State must be 'NEW' or 'DISPATCHED'. If 'DISPATCHED', may become
   // 'DEPENDENCIES_COMPLETED'.
   void OnDependenyCompleted();
 
-  WorkItem work_item_ GUARDED_BY(mutex_);
-  ThreadPoolInterface* thread_pool_to_notify_ GUARDED_BY(mutex_) = nullptr;
-  State state_ GUARDED_BY(mutex_) = NEW;
-  unsigned int uncompleted_dependencies_ GUARDED_BY(mutex_) = 0;
-  std::set<Task*> dependent_tasks_ GUARDED_BY(mutex_);
+  WorkItem work_item_ ABSL_GUARDED_BY(mutex_);
+  ThreadPoolInterface* thread_pool_to_notify_ ABSL_GUARDED_BY(mutex_) = nullptr;
+  State state_ ABSL_GUARDED_BY(mutex_) = NEW;
+  unsigned int uncompleted_dependencies_ ABSL_GUARDED_BY(mutex_) = 0;
+  std::set<Task*> dependent_tasks_ ABSL_GUARDED_BY(mutex_);
 
   absl::Mutex mutex_;
 };
diff --git a/cartographer/common/thread_pool.cc b/cartographer/common/thread_pool.cc
index 2457152..f4681fa 100644
--- a/cartographer/common/thread_pool.cc
+++ b/cartographer/common/thread_pool.cc
@@ -83,7 +83,7 @@ void ThreadPool::DoWork() {
   // away CPU resources from more important foreground threads.
   CHECK_NE(nice(10), -1);
 #endif
-  const auto predicate = [this]() EXCLUSIVE_LOCKS_REQUIRED(mutex_) {
+  const auto predicate = [this]() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_) {
     return !task_queue_.empty() || !running_;
   };
   for (;;) {
diff --git a/cartographer/common/thread_pool.h b/cartographer/common/thread_pool.h
index 3f6b94c..e98311b 100644
--- a/cartographer/common/thread_pool.h
+++ b/cartographer/common/thread_pool.h
@@ -65,19 +65,19 @@ class ThreadPool : public ThreadPoolInterface {
   // When the returned weak pointer is expired, 'task' has certainly completed,
   // so dependants no longer need to add it as a dependency.
   std::weak_ptr<Task> Schedule(std::unique_ptr<Task> task)
-      LOCKS_EXCLUDED(mutex_) override;
+      ABSL_LOCKS_EXCLUDED(mutex_) override;
 
  private:
   void DoWork();
 
-  void NotifyDependenciesCompleted(Task* task) LOCKS_EXCLUDED(mutex_) override;
+  void NotifyDependenciesCompleted(Task* task) ABSL_LOCKS_EXCLUDED(mutex_) override;
 
   absl::Mutex mutex_;
-  bool running_ GUARDED_BY(mutex_) = true;
-  std::vector<std::thread> pool_ GUARDED_BY(mutex_);
-  std::deque<std::shared_ptr<Task>> task_queue_ GUARDED_BY(mutex_);
+  bool running_ ABSL_GUARDED_BY(mutex_) = true;
+  std::vector<std::thread> pool_ ABSL_GUARDED_BY(mutex_);
+  std::deque<std::shared_ptr<Task>> task_queue_ ABSL_GUARDED_BY(mutex_);
   absl::flat_hash_map<Task*, std::shared_ptr<Task>> tasks_not_ready_
-      GUARDED_BY(mutex_);
+      ABSL_GUARDED_BY(mutex_);
 };
 
 }  // namespace common
diff --git a/cartographer/common/thread_pool_test.cc b/cartographer/common/thread_pool_test.cc
index fec82ee..6b44f32 100644
--- a/cartographer/common/thread_pool_test.cc
+++ b/cartographer/common/thread_pool_test.cc
@@ -34,7 +34,7 @@ class Receiver {
 
   void WaitForNumberSequence(const std::vector<int>& expected_numbers) {
     const auto predicate =
-        [this, &expected_numbers]() EXCLUSIVE_LOCKS_REQUIRED(mutex_) {
+        [this, &expected_numbers]() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_) {
           return (received_numbers_.size() >= expected_numbers.size());
         };
     absl::MutexLock locker(&mutex_);
@@ -43,7 +43,7 @@ class Receiver {
   }
 
   absl::Mutex mutex_;
-  std::vector<int> received_numbers_ GUARDED_BY(mutex_);
+  std::vector<int> received_numbers_ ABSL_GUARDED_BY(mutex_);
 };
 
 TEST(ThreadPoolTest, RunTask) {
diff --git a/cartographer/mapping/internal/2d/local_trajectory_builder_2d.cc b/cartographer/mapping/internal/2d/local_trajectory_builder_2d.cc
index 5bda793..1290c6f 100644
--- a/cartographer/mapping/internal/2d/local_trajectory_builder_2d.cc
+++ b/cartographer/mapping/internal/2d/local_trajectory_builder_2d.cc
@@ -197,7 +197,8 @@ LocalTrajectoryBuilder2D::AddRangeData(
         extrapolator_->EstimateGravityOrientation(time));
     // TODO(gaschler): This assumes that 'range_data_poses.back()' is at time
     // 'time'.
-    accumulated_range_data_.origin = range_data_poses.back().translation();
+    // accumulated_range_data_.origin = range_data_poses.back().translation();
+    accumulated_range_data_.origin = range_data_poses.back() * synchronized_data.origins.back();
     return AddAccumulatedRangeData(
         time,
         TransformToGravityAlignedFrameAndFilter(
diff --git a/cartographer/mapping/internal/2d/pose_graph_2d.cc b/cartographer/mapping/internal/2d/pose_graph_2d.cc
index 060277e..623a958 100644
--- a/cartographer/mapping/internal/2d/pose_graph_2d.cc
+++ b/cartographer/mapping/internal/2d/pose_graph_2d.cc
@@ -164,7 +164,7 @@ NodeId PoseGraph2D::AddNode(
   // execute the lambda.
   const bool newly_finished_submap =
       insertion_submaps.front()->insertion_finished();
-  AddWorkItem([=]() LOCKS_EXCLUDED(mutex_) {
+  AddWorkItem([=]() ABSL_LOCKS_EXCLUDED(mutex_) {
     return ComputeConstraintsForNode(node_id, insertion_submaps,
                                      newly_finished_submap);
   });
@@ -208,7 +208,7 @@ void PoseGraph2D::AddTrajectoryIfNeeded(const int trajectory_id) {
 
 void PoseGraph2D::AddImuData(const int trajectory_id,
                              const sensor::ImuData& imu_data) {
-  AddWorkItem([=]() LOCKS_EXCLUDED(mutex_) {
+  AddWorkItem([=]() ABSL_LOCKS_EXCLUDED(mutex_) {
     absl::MutexLock locker(&mutex_);
     if (CanAddWorkItemModifying(trajectory_id)) {
       optimization_problem_->AddImuData(trajectory_id, imu_data);
@@ -219,7 +219,7 @@ void PoseGraph2D::AddImuData(const int trajectory_id,
 
 void PoseGraph2D::AddOdometryData(const int trajectory_id,
                                   const sensor::OdometryData& odometry_data) {
-  AddWorkItem([=]() LOCKS_EXCLUDED(mutex_) {
+  AddWorkItem([=]() ABSL_LOCKS_EXCLUDED(mutex_) {
     absl::MutexLock locker(&mutex_);
     if (CanAddWorkItemModifying(trajectory_id)) {
       optimization_problem_->AddOdometryData(trajectory_id, odometry_data);
@@ -231,7 +231,7 @@ void PoseGraph2D::AddOdometryData(const int trajectory_id,
 void PoseGraph2D::AddFixedFramePoseData(
     const int trajectory_id,
     const sensor::FixedFramePoseData& fixed_frame_pose_data) {
-  AddWorkItem([=]() LOCKS_EXCLUDED(mutex_) {
+  AddWorkItem([=]() ABSL_LOCKS_EXCLUDED(mutex_) {
     absl::MutexLock locker(&mutex_);
     if (CanAddWorkItemModifying(trajectory_id)) {
       optimization_problem_->AddFixedFramePoseData(trajectory_id,
@@ -243,7 +243,7 @@ void PoseGraph2D::AddFixedFramePoseData(
 
 void PoseGraph2D::AddLandmarkData(int trajectory_id,
                                   const sensor::LandmarkData& landmark_data) {
-  AddWorkItem([=]() LOCKS_EXCLUDED(mutex_) {
+  AddWorkItem([=]() ABSL_LOCKS_EXCLUDED(mutex_) {
     absl::MutexLock locker(&mutex_);
     if (CanAddWorkItemModifying(trajectory_id)) {
       for (const auto& observation : landmark_data.landmark_observations) {
@@ -480,6 +480,88 @@ void PoseGraph2D::HandleWorkQueue(
     for (const Constraint& constraint : result) {
       UpdateTrajectoryConnectivity(constraint);
     }
+    std::set<int> mapping_ids;
+    std::set<int> localization_ids;
+    std::set<int> previous_map_ids;
+    std::map<int, common::Time> relocalization_last_connection_time;
+    std::map<int, std::vector<int>> relocalization_to_other_trajectories;
+    for (const auto trajectory_id_mode : trajectories_mode_) {
+      if (trajectory_id_mode.second == TrajectoryMode::MAPPING) {
+        mapping_ids.insert(trajectory_id_mode.first);
+      } else if (trajectory_id_mode.second == TrajectoryMode::LOCALIZATION) {
+        localization_ids.insert(trajectory_id_mode.first);
+      } else if (trajectory_id_mode.second == TrajectoryMode::PREVIOUS_MAP) {
+        previous_map_ids.insert(trajectory_id_mode.first);
+      }
+    }
+    for (const int localization_id : localization_ids) {
+      for (const int previous_map_id : previous_map_ids) {
+        if (data_.trajectory_connectivity_state.TransitivelyConnected(
+            localization_id,
+            previous_map_id)) {
+          common::Time time_last_connection =
+              data_.trajectory_connectivity_state.LastConnectionTime(
+                  localization_id, previous_map_id);
+          common::Time time_last_node_id = data_.trajectory_nodes.at(std::prev(
+              data_.trajectory_nodes.EndOfTrajectory(localization_id))->id).time();
+          relocalization_last_connection_time[localization_id] = time_last_connection;
+          relocalization_to_other_trajectories[localization_id].push_back(previous_map_id);
+          LOG(INFO) << "\n############### Localization Connect to Map ################"
+                    << "\nLocalization Mode Trajectory ID: " << localization_id
+                    << "\nConnected with Map ID: " << previous_map_id
+                    << "\nLast connection Time:  " << time_last_connection
+                    << "\nLast Node Id Time:     " << time_last_node_id
+                    << "\nDelta t: "
+                    << common::ToSeconds(time_last_node_id - time_last_connection)
+                    << "s";
+        }
+      }
+      for (const int mapping_id : mapping_ids) {
+        if (!IsTrajectoryFinished(mapping_id)) {
+          continue;
+        }
+        if (data_.trajectory_connectivity_state.TransitivelyConnected(
+            localization_id,
+            mapping_id)) {
+          common::Time time_last_connection =
+              data_.trajectory_connectivity_state.LastConnectionTime(
+                  localization_id, mapping_id);
+          common::Time time_last_node_id = data_.trajectory_nodes.at(std::prev(
+              data_.trajectory_nodes.EndOfTrajectory(localization_id))->id).time();
+          relocalization_last_connection_time[localization_id] = time_last_connection;
+          relocalization_to_other_trajectories[localization_id].push_back(mapping_id);
+          LOG(INFO) << "\n###### Localization Connect to Newly Build Map #########"
+                    << "\nLocalization Mode Trajectory ID: " << localization_id
+                    << "\nConnected with Map ID: " << mapping_id
+                    << "\nLast connection Time:  " << time_last_connection
+                    << "\nLast Node Id Time:     " << time_last_node_id
+                    << "\nDelta t: "
+                    << common::ToSeconds(time_last_node_id - time_last_connection)
+                    << "s";
+        }
+      }
+    }
+    for (const int mapping_id : mapping_ids) {
+      if (IsTrajectoryFinished(mapping_id)) {
+        continue;
+      }
+      common::Time time_last_connection =
+          data_.trajectory_connectivity_state.LastConnectionTime(
+              mapping_id, mapping_id);
+      common::Time time_last_node_id = data_.trajectory_nodes.at(std::prev(
+          data_.trajectory_nodes.EndOfTrajectory(mapping_id))->id).time();
+      LOG(INFO) << "\n############### Mapping Loop Detection ################"
+                << "\nMapping Mode Trajectory ID: " << mapping_id
+                << "\nLast connection Time:  " << time_last_connection
+                << "\nLast Node Id Time:     " << time_last_node_id
+                << "\nDelta t: "
+                << common::ToSeconds(time_last_node_id - time_last_connection)
+                << "s";
+    }
+    if (re_localization_result_callback_) {
+      re_localization_result_callback_(relocalization_last_connection_time,
+                                       relocalization_to_other_trajectories);
+    }
     DeleteTrajectoriesIfNeeded();
     TrimmingHandle trimming_handle(this);
     for (auto& trimmer : trimmers_) {
@@ -572,7 +654,7 @@ void PoseGraph2D::WaitForAllComputations() {
   // a WhenDone() callback.
   {
     const auto predicate = [this]()
-                               EXCLUSIVE_LOCKS_REQUIRED(work_queue_mutex_) {
+                               ABSL_EXCLUSIVE_LOCKS_REQUIRED(work_queue_mutex_) {
                                  return work_queue_ == nullptr;
                                };
     absl::MutexLock locker(&work_queue_mutex_);
@@ -589,13 +671,13 @@ void PoseGraph2D::WaitForAllComputations() {
   constraint_builder_.WhenDone(
       [this,
        &notification](const constraints::ConstraintBuilder2D::Result& result)
-          LOCKS_EXCLUDED(mutex_) {
+          ABSL_LOCKS_EXCLUDED(mutex_) {
             absl::MutexLock locker(&mutex_);
             data_.constraints.insert(data_.constraints.end(), result.begin(),
                                      result.end());
             notification = true;
           });
-  const auto predicate = [&notification]() EXCLUSIVE_LOCKS_REQUIRED(mutex_) {
+  const auto predicate = [&notification]() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_) {
     return notification;
   };
   while (!mutex_.AwaitWithTimeout(absl::Condition(&predicate),
@@ -618,7 +700,7 @@ void PoseGraph2D::DeleteTrajectory(const int trajectory_id) {
     it->second.deletion_state =
         InternalTrajectoryState::DeletionState::SCHEDULED_FOR_DELETION;
   }
-  AddWorkItem([this, trajectory_id]() LOCKS_EXCLUDED(mutex_) {
+  AddWorkItem([this, trajectory_id]() ABSL_LOCKS_EXCLUDED(mutex_) {
     absl::MutexLock locker(&mutex_);
     CHECK(data_.trajectories_state.at(trajectory_id).state !=
           TrajectoryState::ACTIVE);
@@ -633,7 +715,7 @@ void PoseGraph2D::DeleteTrajectory(const int trajectory_id) {
 }
 
 void PoseGraph2D::FinishTrajectory(const int trajectory_id) {
-  AddWorkItem([this, trajectory_id]() LOCKS_EXCLUDED(mutex_) {
+  AddWorkItem([this, trajectory_id]() ABSL_LOCKS_EXCLUDED(mutex_) {
     absl::MutexLock locker(&mutex_);
     CHECK(!IsTrajectoryFinished(trajectory_id));
     data_.trajectories_state[trajectory_id].state = TrajectoryState::FINISHED;
@@ -656,7 +738,7 @@ void PoseGraph2D::FreezeTrajectory(const int trajectory_id) {
     absl::MutexLock locker(&mutex_);
     data_.trajectory_connectivity_state.Add(trajectory_id);
   }
-  AddWorkItem([this, trajectory_id]() LOCKS_EXCLUDED(mutex_) {
+  AddWorkItem([this, trajectory_id]() ABSL_LOCKS_EXCLUDED(mutex_) {
     absl::MutexLock locker(&mutex_);
     CHECK(!IsTrajectoryFrozen(trajectory_id));
     // Connect multiple frozen trajectories among each other.
@@ -720,7 +802,7 @@ void PoseGraph2D::AddSubmapFromProto(
   }
 
   AddWorkItem(
-      [this, submap_id, global_submap_pose_2d]() LOCKS_EXCLUDED(mutex_) {
+      [this, submap_id, global_submap_pose_2d]() ABSL_LOCKS_EXCLUDED(mutex_) {
         absl::MutexLock locker(&mutex_);
         data_.submap_data.at(submap_id).state = SubmapState::kFinished;
         optimization_problem_->InsertSubmap(submap_id, global_submap_pose_2d);
@@ -743,7 +825,7 @@ void PoseGraph2D::AddNodeFromProto(const transform::Rigid3d& global_pose,
                                   TrajectoryNode{constant_data, global_pose});
   }
 
-  AddWorkItem([this, node_id, global_pose]() LOCKS_EXCLUDED(mutex_) {
+  AddWorkItem([this, node_id, global_pose]() ABSL_LOCKS_EXCLUDED(mutex_) {
     absl::MutexLock locker(&mutex_);
     const auto& constant_data =
         data_.trajectory_nodes.at(node_id).constant_data;
@@ -772,7 +854,7 @@ void PoseGraph2D::SetTrajectoryDataFromProto(
 
     const int trajectory_id = data.trajectory_id();
     AddWorkItem([this, trajectory_id, trajectory_data]()
-                    LOCKS_EXCLUDED(mutex_) {
+                    ABSL_LOCKS_EXCLUDED(mutex_) {
                       absl::MutexLock locker(&mutex_);
                       if (CanAddWorkItemModifying(trajectory_id)) {
                         optimization_problem_->SetTrajectoryData(
@@ -785,7 +867,7 @@ void PoseGraph2D::SetTrajectoryDataFromProto(
 
 void PoseGraph2D::AddNodeToSubmap(const NodeId& node_id,
                                   const SubmapId& submap_id) {
-  AddWorkItem([this, node_id, submap_id]() LOCKS_EXCLUDED(mutex_) {
+  AddWorkItem([this, node_id, submap_id]() ABSL_LOCKS_EXCLUDED(mutex_) {
     absl::MutexLock locker(&mutex_);
     if (CanAddWorkItemModifying(submap_id.trajectory_id)) {
       data_.submap_data.at(submap_id).node_ids.insert(node_id);
@@ -796,7 +878,7 @@ void PoseGraph2D::AddNodeToSubmap(const NodeId& node_id,
 
 void PoseGraph2D::AddSerializedConstraints(
     const std::vector<Constraint>& constraints) {
-  AddWorkItem([this, constraints]() LOCKS_EXCLUDED(mutex_) {
+  AddWorkItem([this, constraints]() ABSL_LOCKS_EXCLUDED(mutex_) {
     absl::MutexLock locker(&mutex_);
     for (const auto& constraint : constraints) {
       CHECK(data_.trajectory_nodes.Contains(constraint.node_id));
@@ -831,7 +913,7 @@ void PoseGraph2D::AddSerializedConstraints(
 void PoseGraph2D::AddTrimmer(std::unique_ptr<PoseGraphTrimmer> trimmer) {
   // C++11 does not allow us to move a unique_ptr into a lambda.
   PoseGraphTrimmer* const trimmer_ptr = trimmer.release();
-  AddWorkItem([this, trimmer_ptr]() LOCKS_EXCLUDED(mutex_) {
+  AddWorkItem([this, trimmer_ptr]() ABSL_LOCKS_EXCLUDED(mutex_) {
     absl::MutexLock locker(&mutex_);
     trimmers_.emplace_back(trimmer_ptr);
     return WorkItem::Result::kDoNotRunOptimization;
@@ -840,13 +922,13 @@ void PoseGraph2D::AddTrimmer(std::unique_ptr<PoseGraphTrimmer> trimmer) {
 
 void PoseGraph2D::RunFinalOptimization() {
   {
-    AddWorkItem([this]() LOCKS_EXCLUDED(mutex_) {
+    AddWorkItem([this]() ABSL_LOCKS_EXCLUDED(mutex_) {
       absl::MutexLock locker(&mutex_);
       optimization_problem_->SetMaxNumIterations(
           options_.max_num_final_iterations());
       return WorkItem::Result::kRunOptimization;
     });
-    AddWorkItem([this]() LOCKS_EXCLUDED(mutex_) {
+    AddWorkItem([this]() ABSL_LOCKS_EXCLUDED(mutex_) {
       absl::MutexLock locker(&mutex_);
       optimization_problem_->SetMaxNumIterations(
           options_.optimization_problem_options()
@@ -985,7 +1067,7 @@ std::map<std::string, transform::Rigid3d> PoseGraph2D::GetLandmarkPoses()
 void PoseGraph2D::SetLandmarkPose(const std::string& landmark_id,
                                   const transform::Rigid3d& global_pose,
                                   const bool frozen) {
-  AddWorkItem([=]() LOCKS_EXCLUDED(mutex_) {
+  AddWorkItem([=]() ABSL_LOCKS_EXCLUDED(mutex_) {
     absl::MutexLock locker(&mutex_);
     data_.landmark_nodes[landmark_id].global_landmark_pose = global_pose;
     data_.landmark_nodes[landmark_id].frozen = frozen;
@@ -993,6 +1075,16 @@ void PoseGraph2D::SetLandmarkPose(const std::string& landmark_id,
   });
 }
 
+void PoseGraph2D::SetTrajectoryMode(const int trajectory_id,
+                                    const TrajectoryMode mode) {
+  absl::MutexLock locker(&mutex_);
+  trajectories_mode_[trajectory_id] = mode;
+}
+const std::unordered_map<int, PoseGraphInterface::TrajectoryMode>&
+PoseGraph2D::GetAllTrajectoryMode() const {
+  absl::MutexLock locker(&mutex_);
+  return trajectories_mode_;
+}
 sensor::MapByTime<sensor::ImuData> PoseGraph2D::GetImuData() const {
   absl::MutexLock locker(&mutex_);
   return optimization_problem_->imu_data();
@@ -1313,6 +1405,10 @@ void PoseGraph2D::SetGlobalSlamOptimizationCallback(
   global_slam_optimization_callback_ = callback;
 }
 
+void PoseGraph2D::SetReLocalizationResultCallback(
+    PoseGraphInterface::RelocalizationResultCallback callback) {
+  re_localization_result_callback_ = callback;
+}
 void PoseGraph2D::RegisterMetrics(metrics::FamilyFactory* family_factory) {
   auto* latency = family_factory->NewGaugeFamily(
       "mapping_2d_pose_graph_work_queue_delay",
diff --git a/cartographer/mapping/internal/2d/pose_graph_2d.h b/cartographer/mapping/internal/2d/pose_graph_2d.h
index 3733425..3d7be0e 100644
--- a/cartographer/mapping/internal/2d/pose_graph_2d.h
+++ b/cartographer/mapping/internal/2d/pose_graph_2d.h
@@ -81,28 +81,28 @@ class PoseGraph2D : public PoseGraph {
       std::shared_ptr<const TrajectoryNode::Data> constant_data,
       int trajectory_id,
       const std::vector<std::shared_ptr<const Submap2D>>& insertion_submaps)
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
 
   void AddImuData(int trajectory_id, const sensor::ImuData& imu_data) override
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
   void AddOdometryData(int trajectory_id,
                        const sensor::OdometryData& odometry_data) override
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
   void AddFixedFramePoseData(
       int trajectory_id,
       const sensor::FixedFramePoseData& fixed_frame_pose_data) override
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
   void AddLandmarkData(int trajectory_id,
                        const sensor::LandmarkData& landmark_data) override
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
 
   void DeleteTrajectory(int trajectory_id) override;
   void FinishTrajectory(int trajectory_id) override;
   bool IsTrajectoryFinished(int trajectory_id) const override
-      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
   void FreezeTrajectory(int trajectory_id) override;
   bool IsTrajectoryFrozen(int trajectory_id) const override
-      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
   void AddSubmapFromProto(const transform::Rigid3d& global_submap_pose,
                           const proto::Submap& submap) override;
   void AddNodeFromProto(const transform::Rigid3d& global_pose,
@@ -115,61 +115,67 @@ class PoseGraph2D : public PoseGraph {
   void AddTrimmer(std::unique_ptr<PoseGraphTrimmer> trimmer) override;
   void RunFinalOptimization() override;
   std::vector<std::vector<int>> GetConnectedTrajectories() const override
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
   PoseGraphInterface::SubmapData GetSubmapData(const SubmapId& submap_id) const
-      LOCKS_EXCLUDED(mutex_) override;
+      ABSL_LOCKS_EXCLUDED(mutex_) override;
   MapById<SubmapId, PoseGraphInterface::SubmapData> GetAllSubmapData() const
-      LOCKS_EXCLUDED(mutex_) override;
+      ABSL_LOCKS_EXCLUDED(mutex_) override;
   MapById<SubmapId, SubmapPose> GetAllSubmapPoses() const
-      LOCKS_EXCLUDED(mutex_) override;
+      ABSL_LOCKS_EXCLUDED(mutex_) override;
   transform::Rigid3d GetLocalToGlobalTransform(int trajectory_id) const
-      LOCKS_EXCLUDED(mutex_) override;
+      ABSL_LOCKS_EXCLUDED(mutex_) override;
   MapById<NodeId, TrajectoryNode> GetTrajectoryNodes() const override
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
   MapById<NodeId, TrajectoryNodePose> GetTrajectoryNodePoses() const override
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
   std::map<int, TrajectoryState> GetTrajectoryStates() const override
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
   std::map<std::string, transform::Rigid3d> GetLandmarkPoses() const override
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
   void SetLandmarkPose(const std::string& landmark_id,
                        const transform::Rigid3d& global_pose,
                        const bool frozen = false) override
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
   sensor::MapByTime<sensor::ImuData> GetImuData() const override
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
   sensor::MapByTime<sensor::OdometryData> GetOdometryData() const override
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
   sensor::MapByTime<sensor::FixedFramePoseData> GetFixedFramePoseData()
-      const override LOCKS_EXCLUDED(mutex_);
+      const override ABSL_LOCKS_EXCLUDED(mutex_);
   std::map<std::string /* landmark ID */, PoseGraph::LandmarkNode>
-  GetLandmarkNodes() const override LOCKS_EXCLUDED(mutex_);
+  GetLandmarkNodes() const override ABSL_LOCKS_EXCLUDED(mutex_);
   std::map<int, TrajectoryData> GetTrajectoryData() const override
-      LOCKS_EXCLUDED(mutex_);
-  std::vector<Constraint> constraints() const override LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
+  std::vector<Constraint> constraints() const override ABSL_LOCKS_EXCLUDED(mutex_);
   void SetInitialTrajectoryPose(int from_trajectory_id, int to_trajectory_id,
                                 const transform::Rigid3d& pose,
                                 const common::Time time) override
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
   void SetGlobalSlamOptimizationCallback(
       PoseGraphInterface::GlobalSlamOptimizationCallback callback) override;
+  void SetReLocalizationResultCallback(
+      PoseGraphInterface::RelocalizationResultCallback callback) override;
   transform::Rigid3d GetInterpolatedGlobalTrajectoryPose(
       int trajectory_id, const common::Time time) const
-      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+  void SetTrajectoryMode(const int trajectory_id, const TrajectoryMode mode) override
+      ABSL_LOCKS_EXCLUDED(mutex_);
+  const std::unordered_map<int, PoseGraphInterface::TrajectoryMode>&
+  GetAllTrajectoryMode() const override ABSL_LOCKS_EXCLUDED(mutex_);
 
   static void RegisterMetrics(metrics::FamilyFactory* family_factory);
 
  private:
   MapById<SubmapId, PoseGraphInterface::SubmapData> GetSubmapDataUnderLock()
-      const EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+      const ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
 
   // Handles a new work item.
   void AddWorkItem(const std::function<WorkItem::Result()>& work_item)
-      LOCKS_EXCLUDED(mutex_) LOCKS_EXCLUDED(work_queue_mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_) ABSL_LOCKS_EXCLUDED(work_queue_mutex_);
 
   // Adds connectivity and sampler for a trajectory if it does not exist.
   void AddTrajectoryIfNeeded(int trajectory_id)
-      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
 
   // Appends the new node and submap (if needed) to the internal data
   // structures.
@@ -177,82 +183,83 @@ class PoseGraph2D : public PoseGraph {
       std::shared_ptr<const TrajectoryNode::Data> constant_data,
       int trajectory_id,
       const std::vector<std::shared_ptr<const Submap2D>>& insertion_submaps,
-      const transform::Rigid3d& optimized_pose) LOCKS_EXCLUDED(mutex_);
+      const transform::Rigid3d& optimized_pose) ABSL_LOCKS_EXCLUDED(mutex_);
 
   // Grows the optimization problem to have an entry for every element of
   // 'insertion_submaps'. Returns the IDs for the 'insertion_submaps'.
   std::vector<SubmapId> InitializeGlobalSubmapPoses(
       int trajectory_id, const common::Time time,
       const std::vector<std::shared_ptr<const Submap2D>>& insertion_submaps)
-      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
 
   // Adds constraints for a node, and starts scan matching in the background.
   WorkItem::Result ComputeConstraintsForNode(
       const NodeId& node_id,
       std::vector<std::shared_ptr<const Submap2D>> insertion_submaps,
-      bool newly_finished_submap) LOCKS_EXCLUDED(mutex_);
+      bool newly_finished_submap) ABSL_LOCKS_EXCLUDED(mutex_);
 
   // Computes constraints for a node and submap pair.
   void ComputeConstraint(const NodeId& node_id, const SubmapId& submap_id)
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
 
   // Deletes trajectories waiting for deletion. Must not be called during
   // constraint search.
-  void DeleteTrajectoriesIfNeeded() EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+  void DeleteTrajectoriesIfNeeded() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
 
   // Runs the optimization, executes the trimmers and processes the work queue.
   void HandleWorkQueue(const constraints::ConstraintBuilder2D::Result& result)
-      LOCKS_EXCLUDED(mutex_) LOCKS_EXCLUDED(work_queue_mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_) ABSL_LOCKS_EXCLUDED(work_queue_mutex_);
 
   // Process pending tasks in the work queue on the calling thread, until the
   // queue is either empty or an optimization is required.
-  void DrainWorkQueue() LOCKS_EXCLUDED(mutex_)
-      LOCKS_EXCLUDED(work_queue_mutex_);
+  void DrainWorkQueue() ABSL_LOCKS_EXCLUDED(mutex_)
+      ABSL_LOCKS_EXCLUDED(work_queue_mutex_);
 
   // Waits until we caught up (i.e. nothing is waiting to be scheduled), and
   // all computations have finished.
-  void WaitForAllComputations() LOCKS_EXCLUDED(mutex_)
-      LOCKS_EXCLUDED(work_queue_mutex_);
+  void WaitForAllComputations() ABSL_LOCKS_EXCLUDED(mutex_)
+      ABSL_LOCKS_EXCLUDED(work_queue_mutex_);
 
   // Runs the optimization. Callers have to make sure, that there is only one
   // optimization being run at a time.
-  void RunOptimization() LOCKS_EXCLUDED(mutex_);
+  void RunOptimization() ABSL_LOCKS_EXCLUDED(mutex_);
 
   bool CanAddWorkItemModifying(int trajectory_id)
-      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
 
   // Computes the local to global map frame transform based on the given
   // 'global_submap_poses'.
   transform::Rigid3d ComputeLocalToGlobalTransform(
       const MapById<SubmapId, optimization::SubmapSpec2D>& global_submap_poses,
-      int trajectory_id) const EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+      int trajectory_id) const ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
 
   SubmapData GetSubmapDataUnderLock(const SubmapId& submap_id) const
-      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
 
   common::Time GetLatestNodeTime(const NodeId& node_id,
                                  const SubmapId& submap_id) const
-      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
 
   // Updates the trajectory connectivity structure with a new constraint.
   void UpdateTrajectoryConnectivity(const Constraint& constraint)
-      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
 
   const proto::PoseGraphOptions options_;
+  RelocalizationResultCallback re_localization_result_callback_;
   GlobalSlamOptimizationCallback global_slam_optimization_callback_;
   mutable absl::Mutex mutex_;
   absl::Mutex work_queue_mutex_;
 
   // If it exists, further work items must be added to this queue, and will be
   // considered later.
-  std::unique_ptr<WorkQueue> work_queue_ GUARDED_BY(work_queue_mutex_);
+  std::unique_ptr<WorkQueue> work_queue_ ABSL_GUARDED_BY(work_queue_mutex_);
 
   // We globally localize a fraction of the nodes from each trajectory.
   absl::flat_hash_map<int, std::unique_ptr<common::FixedRatioSampler>>
-      global_localization_samplers_ GUARDED_BY(mutex_);
+      global_localization_samplers_ ABSL_GUARDED_BY(mutex_);
 
   // Number of nodes added since last loop closure.
-  int num_nodes_since_last_loop_closure_ GUARDED_BY(mutex_) = 0;
+  int num_nodes_since_last_loop_closure_ ABSL_GUARDED_BY(mutex_) = 0;
 
   // Current optimization problem.
   std::unique_ptr<optimization::OptimizationProblem2D> optimization_problem_;
@@ -262,11 +269,12 @@ class PoseGraph2D : public PoseGraph {
   common::ThreadPool* const thread_pool_;
 
   // List of all trimmers to consult when optimizations finish.
-  std::vector<std::unique_ptr<PoseGraphTrimmer>> trimmers_ GUARDED_BY(mutex_);
+  std::vector<std::unique_ptr<PoseGraphTrimmer>> trimmers_ ABSL_GUARDED_BY(mutex_);
 
-  PoseGraphData data_ GUARDED_BY(mutex_);
+  PoseGraphData data_ ABSL_GUARDED_BY(mutex_);
 
   ValueConversionTables conversion_tables_;
+  std::unordered_map<int, TrajectoryMode> trajectories_mode_;
 
   // Allows querying and manipulating the pose graph by the 'trimmers_'. The
   // 'mutex_' of the pose graph is held while this class is used.
@@ -278,17 +286,17 @@ class PoseGraph2D : public PoseGraph {
     int num_submaps(int trajectory_id) const override;
     std::vector<SubmapId> GetSubmapIds(int trajectory_id) const override;
     MapById<SubmapId, SubmapData> GetOptimizedSubmapData() const override
-        EXCLUSIVE_LOCKS_REQUIRED(parent_->mutex_);
+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(parent_->mutex_);
     const MapById<NodeId, TrajectoryNode>& GetTrajectoryNodes() const override
-        EXCLUSIVE_LOCKS_REQUIRED(parent_->mutex_);
+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(parent_->mutex_);
     const std::vector<Constraint>& GetConstraints() const override
-        EXCLUSIVE_LOCKS_REQUIRED(parent_->mutex_);
+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(parent_->mutex_);
     void TrimSubmap(const SubmapId& submap_id)
-        EXCLUSIVE_LOCKS_REQUIRED(parent_->mutex_) override;
+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(parent_->mutex_) override;
     bool IsFinished(int trajectory_id) const override
-        EXCLUSIVE_LOCKS_REQUIRED(parent_->mutex_);
+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(parent_->mutex_);
     void SetTrajectoryState(int trajectory_id, TrajectoryState state) override
-        EXCLUSIVE_LOCKS_REQUIRED(parent_->mutex_);
+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(parent_->mutex_);
 
    private:
     PoseGraph2D* const parent_;
diff --git a/cartographer/mapping/internal/3d/pose_graph_3d.cc b/cartographer/mapping/internal/3d/pose_graph_3d.cc
index 8a91e59..50c60ec 100644
--- a/cartographer/mapping/internal/3d/pose_graph_3d.cc
+++ b/cartographer/mapping/internal/3d/pose_graph_3d.cc
@@ -152,7 +152,7 @@ NodeId PoseGraph3D::AddNode(
   // execute the lambda.
   const bool newly_finished_submap =
       insertion_submaps.front()->insertion_finished();
-  AddWorkItem([=]() LOCKS_EXCLUDED(mutex_) {
+  AddWorkItem([=]() ABSL_LOCKS_EXCLUDED(mutex_) {
     return ComputeConstraintsForNode(node_id, insertion_submaps,
                                      newly_finished_submap);
   });
@@ -196,7 +196,7 @@ void PoseGraph3D::AddTrajectoryIfNeeded(const int trajectory_id) {
 
 void PoseGraph3D::AddImuData(const int trajectory_id,
                              const sensor::ImuData& imu_data) {
-  AddWorkItem([=]() LOCKS_EXCLUDED(mutex_) {
+  AddWorkItem([=]() ABSL_LOCKS_EXCLUDED(mutex_) {
     absl::MutexLock locker(&mutex_);
     if (CanAddWorkItemModifying(trajectory_id)) {
       optimization_problem_->AddImuData(trajectory_id, imu_data);
@@ -207,7 +207,7 @@ void PoseGraph3D::AddImuData(const int trajectory_id,
 
 void PoseGraph3D::AddOdometryData(const int trajectory_id,
                                   const sensor::OdometryData& odometry_data) {
-  AddWorkItem([=]() LOCKS_EXCLUDED(mutex_) {
+  AddWorkItem([=]() ABSL_LOCKS_EXCLUDED(mutex_) {
     absl::MutexLock locker(&mutex_);
     if (CanAddWorkItemModifying(trajectory_id)) {
       optimization_problem_->AddOdometryData(trajectory_id, odometry_data);
@@ -219,7 +219,7 @@ void PoseGraph3D::AddOdometryData(const int trajectory_id,
 void PoseGraph3D::AddFixedFramePoseData(
     const int trajectory_id,
     const sensor::FixedFramePoseData& fixed_frame_pose_data) {
-  AddWorkItem([=]() LOCKS_EXCLUDED(mutex_) {
+  AddWorkItem([=]() ABSL_LOCKS_EXCLUDED(mutex_) {
     absl::MutexLock locker(&mutex_);
     if (CanAddWorkItemModifying(trajectory_id)) {
       optimization_problem_->AddFixedFramePoseData(trajectory_id,
@@ -231,7 +231,7 @@ void PoseGraph3D::AddFixedFramePoseData(
 
 void PoseGraph3D::AddLandmarkData(int trajectory_id,
                                   const sensor::LandmarkData& landmark_data) {
-  AddWorkItem([=]() LOCKS_EXCLUDED(mutex_) {
+  AddWorkItem([=]() ABSL_LOCKS_EXCLUDED(mutex_) {
     absl::MutexLock locker(&mutex_);
     if (CanAddWorkItemModifying(trajectory_id)) {
       for (const auto& observation : landmark_data.landmark_observations) {
@@ -559,7 +559,7 @@ void PoseGraph3D::WaitForAllComputations() {
   // a WhenDone() callback.
   {
     const auto predicate = [this]()
-                               EXCLUSIVE_LOCKS_REQUIRED(work_queue_mutex_) {
+                               ABSL_EXCLUSIVE_LOCKS_REQUIRED(work_queue_mutex_) {
                                  return work_queue_ == nullptr;
                                };
     absl::MutexLock locker(&work_queue_mutex_);
@@ -576,13 +576,13 @@ void PoseGraph3D::WaitForAllComputations() {
   constraint_builder_.WhenDone(
       [this,
        &notification](const constraints::ConstraintBuilder3D::Result& result)
-          LOCKS_EXCLUDED(mutex_) {
+          ABSL_LOCKS_EXCLUDED(mutex_) {
             absl::MutexLock locker(&mutex_);
             data_.constraints.insert(data_.constraints.end(), result.begin(),
                                      result.end());
             notification = true;
           });
-  const auto predicate = [&notification]() EXCLUSIVE_LOCKS_REQUIRED(mutex_) {
+  const auto predicate = [&notification]() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_) {
     return notification;
   };
   while (!mutex_.AwaitWithTimeout(absl::Condition(&predicate),
@@ -605,7 +605,7 @@ void PoseGraph3D::DeleteTrajectory(const int trajectory_id) {
     it->second.deletion_state =
         InternalTrajectoryState::DeletionState::SCHEDULED_FOR_DELETION;
   }
-  AddWorkItem([this, trajectory_id]() LOCKS_EXCLUDED(mutex_) {
+  AddWorkItem([this, trajectory_id]() ABSL_LOCKS_EXCLUDED(mutex_) {
     absl::MutexLock locker(&mutex_);
     CHECK(data_.trajectories_state.at(trajectory_id).state !=
           TrajectoryState::ACTIVE);
@@ -620,7 +620,7 @@ void PoseGraph3D::DeleteTrajectory(const int trajectory_id) {
 }
 
 void PoseGraph3D::FinishTrajectory(const int trajectory_id) {
-  AddWorkItem([this, trajectory_id]() LOCKS_EXCLUDED(mutex_) {
+  AddWorkItem([this, trajectory_id]() ABSL_LOCKS_EXCLUDED(mutex_) {
     absl::MutexLock locker(&mutex_);
     CHECK(!IsTrajectoryFinished(trajectory_id));
     data_.trajectories_state[trajectory_id].state = TrajectoryState::FINISHED;
@@ -643,7 +643,7 @@ void PoseGraph3D::FreezeTrajectory(const int trajectory_id) {
     absl::MutexLock locker(&mutex_);
     data_.trajectory_connectivity_state.Add(trajectory_id);
   }
-  AddWorkItem([this, trajectory_id]() LOCKS_EXCLUDED(mutex_) {
+  AddWorkItem([this, trajectory_id]() ABSL_LOCKS_EXCLUDED(mutex_) {
     absl::MutexLock locker(&mutex_);
     CHECK(!IsTrajectoryFrozen(trajectory_id));
     // Connect multiple frozen trajectories among each other.
@@ -703,7 +703,7 @@ void PoseGraph3D::AddSubmapFromProto(
     kActiveSubmapsMetric->Increment();
   }
 
-  AddWorkItem([this, submap_id, global_submap_pose]() LOCKS_EXCLUDED(mutex_) {
+  AddWorkItem([this, submap_id, global_submap_pose]() ABSL_LOCKS_EXCLUDED(mutex_) {
     absl::MutexLock locker(&mutex_);
     data_.submap_data.at(submap_id).state = SubmapState::kFinished;
     optimization_problem_->InsertSubmap(submap_id, global_submap_pose);
@@ -726,7 +726,7 @@ void PoseGraph3D::AddNodeFromProto(const transform::Rigid3d& global_pose,
                                   TrajectoryNode{constant_data, global_pose});
   }
 
-  AddWorkItem([this, node_id, global_pose]() LOCKS_EXCLUDED(mutex_) {
+  AddWorkItem([this, node_id, global_pose]() ABSL_LOCKS_EXCLUDED(mutex_) {
     absl::MutexLock locker(&mutex_);
     const auto& constant_data =
         data_.trajectory_nodes.at(node_id).constant_data;
@@ -751,7 +751,7 @@ void PoseGraph3D::SetTrajectoryDataFromProto(
   }
 
   const int trajectory_id = data.trajectory_id();
-  AddWorkItem([this, trajectory_id, trajectory_data]() LOCKS_EXCLUDED(mutex_) {
+  AddWorkItem([this, trajectory_id, trajectory_data]() ABSL_LOCKS_EXCLUDED(mutex_) {
     absl::MutexLock locker(&mutex_);
     if (CanAddWorkItemModifying(trajectory_id)) {
       optimization_problem_->SetTrajectoryData(trajectory_id, trajectory_data);
@@ -762,7 +762,7 @@ void PoseGraph3D::SetTrajectoryDataFromProto(
 
 void PoseGraph3D::AddNodeToSubmap(const NodeId& node_id,
                                   const SubmapId& submap_id) {
-  AddWorkItem([this, node_id, submap_id]() LOCKS_EXCLUDED(mutex_) {
+  AddWorkItem([this, node_id, submap_id]() ABSL_LOCKS_EXCLUDED(mutex_) {
     absl::MutexLock locker(&mutex_);
     if (CanAddWorkItemModifying(submap_id.trajectory_id)) {
       data_.submap_data.at(submap_id).node_ids.insert(node_id);
@@ -773,7 +773,7 @@ void PoseGraph3D::AddNodeToSubmap(const NodeId& node_id,
 
 void PoseGraph3D::AddSerializedConstraints(
     const std::vector<Constraint>& constraints) {
-  AddWorkItem([this, constraints]() LOCKS_EXCLUDED(mutex_) {
+  AddWorkItem([this, constraints]() ABSL_LOCKS_EXCLUDED(mutex_) {
     absl::MutexLock locker(&mutex_);
     for (const auto& constraint : constraints) {
       CHECK(data_.trajectory_nodes.Contains(constraint.node_id));
@@ -801,7 +801,7 @@ void PoseGraph3D::AddSerializedConstraints(
 void PoseGraph3D::AddTrimmer(std::unique_ptr<PoseGraphTrimmer> trimmer) {
   // C++11 does not allow us to move a unique_ptr into a lambda.
   PoseGraphTrimmer* const trimmer_ptr = trimmer.release();
-  AddWorkItem([this, trimmer_ptr]() LOCKS_EXCLUDED(mutex_) {
+  AddWorkItem([this, trimmer_ptr]() ABSL_LOCKS_EXCLUDED(mutex_) {
     absl::MutexLock locker(&mutex_);
     trimmers_.emplace_back(trimmer_ptr);
     return WorkItem::Result::kDoNotRunOptimization;
@@ -810,13 +810,13 @@ void PoseGraph3D::AddTrimmer(std::unique_ptr<PoseGraphTrimmer> trimmer) {
 
 void PoseGraph3D::RunFinalOptimization() {
   {
-    AddWorkItem([this]() LOCKS_EXCLUDED(mutex_) {
+    AddWorkItem([this]() ABSL_LOCKS_EXCLUDED(mutex_) {
       absl::MutexLock locker(&mutex_);
       optimization_problem_->SetMaxNumIterations(
           options_.max_num_final_iterations());
       return WorkItem::Result::kRunOptimization;
     });
-    AddWorkItem([this]() LOCKS_EXCLUDED(mutex_) {
+    AddWorkItem([this]() ABSL_LOCKS_EXCLUDED(mutex_) {
       absl::MutexLock locker(&mutex_);
       optimization_problem_->SetMaxNumIterations(
           options_.optimization_problem_options()
@@ -982,7 +982,7 @@ std::map<std::string, transform::Rigid3d> PoseGraph3D::GetLandmarkPoses()
 void PoseGraph3D::SetLandmarkPose(const std::string& landmark_id,
                                   const transform::Rigid3d& global_pose,
                                   const bool frozen) {
-  AddWorkItem([=]() LOCKS_EXCLUDED(mutex_) {
+  AddWorkItem([=]() ABSL_LOCKS_EXCLUDED(mutex_) {
     absl::MutexLock locker(&mutex_);
     data_.landmark_nodes[landmark_id].global_landmark_pose = global_pose;
     data_.landmark_nodes[landmark_id].frozen = frozen;
@@ -990,6 +990,16 @@ void PoseGraph3D::SetLandmarkPose(const std::string& landmark_id,
   });
 }
 
+void PoseGraph3D::SetTrajectoryMode(const int trajectory_id,
+                                    const TrajectoryMode mode) {
+  absl::MutexLock locker(&mutex_);
+  trajectories_mode_[trajectory_id] = mode;
+}
+const std::unordered_map<int, PoseGraphInterface::TrajectoryMode>&
+PoseGraph3D::GetAllTrajectoryMode() const {
+  absl::MutexLock locker(&mutex_);
+  return trajectories_mode_;
+}
 sensor::MapByTime<sensor::ImuData> PoseGraph3D::GetImuData() const {
   absl::MutexLock locker(&mutex_);
   return optimization_problem_->imu_data();
@@ -1293,6 +1303,10 @@ void PoseGraph3D::SetGlobalSlamOptimizationCallback(
   global_slam_optimization_callback_ = callback;
 }
 
+void PoseGraph3D::SetReLocalizationResultCallback(
+    PoseGraphInterface::RelocalizationResultCallback callback) {
+  re_localization_result_callback_ = callback;
+}
 void PoseGraph3D::RegisterMetrics(metrics::FamilyFactory* family_factory) {
   auto* latency = family_factory->NewGaugeFamily(
       "mapping_3d_pose_graph_work_queue_delay",
diff --git a/cartographer/mapping/internal/3d/pose_graph_3d.h b/cartographer/mapping/internal/3d/pose_graph_3d.h
index 12a3469..e64217d 100644
--- a/cartographer/mapping/internal/3d/pose_graph_3d.h
+++ b/cartographer/mapping/internal/3d/pose_graph_3d.h
@@ -79,28 +79,28 @@ class PoseGraph3D : public PoseGraph {
       std::shared_ptr<const TrajectoryNode::Data> constant_data,
       int trajectory_id,
       const std::vector<std::shared_ptr<const Submap3D>>& insertion_submaps)
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
 
   void AddImuData(int trajectory_id, const sensor::ImuData& imu_data) override
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
   void AddOdometryData(int trajectory_id,
                        const sensor::OdometryData& odometry_data) override
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
   void AddFixedFramePoseData(
       int trajectory_id,
       const sensor::FixedFramePoseData& fixed_frame_pose_data) override
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
   void AddLandmarkData(int trajectory_id,
                        const sensor::LandmarkData& landmark_data) override
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
 
   void DeleteTrajectory(int trajectory_id) override;
   void FinishTrajectory(int trajectory_id) override;
   bool IsTrajectoryFinished(int trajectory_id) const override
-      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
   void FreezeTrajectory(int trajectory_id) override;
   bool IsTrajectoryFrozen(int trajectory_id) const override
-      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
   void AddSubmapFromProto(const transform::Rigid3d& global_submap_pose,
                           const proto::Submap& submap) override;
   void AddNodeFromProto(const transform::Rigid3d& global_pose,
@@ -113,148 +113,155 @@ class PoseGraph3D : public PoseGraph {
   void AddTrimmer(std::unique_ptr<PoseGraphTrimmer> trimmer) override;
   void RunFinalOptimization() override;
   std::vector<std::vector<int>> GetConnectedTrajectories() const override
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
   PoseGraph::SubmapData GetSubmapData(const SubmapId& submap_id) const
-      LOCKS_EXCLUDED(mutex_) override;
+      ABSL_LOCKS_EXCLUDED(mutex_) override;
   MapById<SubmapId, SubmapData> GetAllSubmapData() const
-      LOCKS_EXCLUDED(mutex_) override;
+      ABSL_LOCKS_EXCLUDED(mutex_) override;
   MapById<SubmapId, SubmapPose> GetAllSubmapPoses() const
-      LOCKS_EXCLUDED(mutex_) override;
+      ABSL_LOCKS_EXCLUDED(mutex_) override;
   transform::Rigid3d GetLocalToGlobalTransform(int trajectory_id) const
-      LOCKS_EXCLUDED(mutex_) override;
+      ABSL_LOCKS_EXCLUDED(mutex_) override;
   MapById<NodeId, TrajectoryNode> GetTrajectoryNodes() const override
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
   MapById<NodeId, TrajectoryNodePose> GetTrajectoryNodePoses() const override
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
   std::map<int, TrajectoryState> GetTrajectoryStates() const override
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
   std::map<std::string, transform::Rigid3d> GetLandmarkPoses() const override
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
   void SetLandmarkPose(const std::string& landmark_id,
                        const transform::Rigid3d& global_pose,
                        const bool frozen = false) override
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
   sensor::MapByTime<sensor::ImuData> GetImuData() const override
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
   sensor::MapByTime<sensor::OdometryData> GetOdometryData() const override
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
   sensor::MapByTime<sensor::FixedFramePoseData> GetFixedFramePoseData()
-      const override LOCKS_EXCLUDED(mutex_);
+      const override ABSL_LOCKS_EXCLUDED(mutex_);
   std::map<std::string /* landmark ID */, PoseGraph::LandmarkNode>
-  GetLandmarkNodes() const override LOCKS_EXCLUDED(mutex_);
+  GetLandmarkNodes() const override ABSL_LOCKS_EXCLUDED(mutex_);
   std::map<int, TrajectoryData> GetTrajectoryData() const override;
 
-  std::vector<Constraint> constraints() const override LOCKS_EXCLUDED(mutex_);
+  std::vector<Constraint> constraints() const override ABSL_LOCKS_EXCLUDED(mutex_);
   void SetInitialTrajectoryPose(int from_trajectory_id, int to_trajectory_id,
                                 const transform::Rigid3d& pose,
                                 const common::Time time) override
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
   void SetGlobalSlamOptimizationCallback(
       PoseGraphInterface::GlobalSlamOptimizationCallback callback) override;
+  void SetReLocalizationResultCallback(
+      PoseGraphInterface::RelocalizationResultCallback callback) override;
   transform::Rigid3d GetInterpolatedGlobalTrajectoryPose(
       int trajectory_id, const common::Time time) const
-      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+  void SetTrajectoryMode(const int trajectory_id, const TrajectoryMode mode) override
+  ABSL_LOCKS_EXCLUDED(mutex_);
+  const std::unordered_map<int, PoseGraphInterface::TrajectoryMode>&
+  GetAllTrajectoryMode() const override ABSL_LOCKS_EXCLUDED(mutex_);
 
   static void RegisterMetrics(metrics::FamilyFactory* family_factory);
 
  protected:
   // Waits until we caught up (i.e. nothing is waiting to be scheduled), and
   // all computations have finished.
-  void WaitForAllComputations() LOCKS_EXCLUDED(mutex_)
-      LOCKS_EXCLUDED(work_queue_mutex_);
+  void WaitForAllComputations() ABSL_LOCKS_EXCLUDED(mutex_)
+      ABSL_LOCKS_EXCLUDED(work_queue_mutex_);
 
  private:
   MapById<SubmapId, SubmapData> GetSubmapDataUnderLock() const
-      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
 
   // Handles a new work item.
   void AddWorkItem(const std::function<WorkItem::Result()>& work_item)
-      LOCKS_EXCLUDED(mutex_) LOCKS_EXCLUDED(work_queue_mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_) ABSL_LOCKS_EXCLUDED(work_queue_mutex_);
 
   // Adds connectivity and sampler for a trajectory if it does not exist.
   void AddTrajectoryIfNeeded(int trajectory_id)
-      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
 
   // Appends the new node and submap (if needed) to the internal data stuctures.
   NodeId AppendNode(
       std::shared_ptr<const TrajectoryNode::Data> constant_data,
       int trajectory_id,
       const std::vector<std::shared_ptr<const Submap3D>>& insertion_submaps,
-      const transform::Rigid3d& optimized_pose) LOCKS_EXCLUDED(mutex_);
+      const transform::Rigid3d& optimized_pose) ABSL_LOCKS_EXCLUDED(mutex_);
 
   // Grows the optimization problem to have an entry for every element of
   // 'insertion_submaps'. Returns the IDs for the 'insertion_submaps'.
   std::vector<SubmapId> InitializeGlobalSubmapPoses(
       int trajectory_id, const common::Time time,
       const std::vector<std::shared_ptr<const Submap3D>>& insertion_submaps)
-      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
 
   // Adds constraints for a node, and starts scan matching in the background.
   WorkItem::Result ComputeConstraintsForNode(
       const NodeId& node_id,
       std::vector<std::shared_ptr<const Submap3D>> insertion_submaps,
-      bool newly_finished_submap) LOCKS_EXCLUDED(mutex_);
+      bool newly_finished_submap) ABSL_LOCKS_EXCLUDED(mutex_);
 
   // Computes constraints for a node and submap pair.
   void ComputeConstraint(const NodeId& node_id, const SubmapId& submap_id)
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
 
   // Deletes trajectories waiting for deletion. Must not be called during
   // constraint search.
-  void DeleteTrajectoriesIfNeeded() EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+  void DeleteTrajectoriesIfNeeded() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
 
   // Runs the optimization, executes the trimmers and processes the work queue.
   void HandleWorkQueue(const constraints::ConstraintBuilder3D::Result& result)
-      LOCKS_EXCLUDED(mutex_) LOCKS_EXCLUDED(work_queue_mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_) ABSL_LOCKS_EXCLUDED(work_queue_mutex_);
 
   // Process pending tasks in the work queue on the calling thread, until the
   // queue is either empty or an optimization is required.
-  void DrainWorkQueue() LOCKS_EXCLUDED(mutex_)
-      LOCKS_EXCLUDED(work_queue_mutex_);
+  void DrainWorkQueue() ABSL_LOCKS_EXCLUDED(mutex_)
+      ABSL_LOCKS_EXCLUDED(work_queue_mutex_);
 
   // Runs the optimization. Callers have to make sure, that there is only one
   // optimization being run at a time.
-  void RunOptimization() LOCKS_EXCLUDED(mutex_);
+  void RunOptimization() ABSL_LOCKS_EXCLUDED(mutex_);
 
   bool CanAddWorkItemModifying(int trajectory_id)
-      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
 
   // Computes the local to global map frame transform based on the given
   // 'global_submap_poses'.
   transform::Rigid3d ComputeLocalToGlobalTransform(
       const MapById<SubmapId, optimization::SubmapSpec3D>& global_submap_poses,
-      int trajectory_id) const EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+      int trajectory_id) const ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
 
   PoseGraph::SubmapData GetSubmapDataUnderLock(const SubmapId& submap_id) const
-      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
 
   common::Time GetLatestNodeTime(const NodeId& node_id,
                                  const SubmapId& submap_id) const
-      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
 
   // Logs histograms for the translational and rotational residual of node
   // poses.
-  void LogResidualHistograms() const EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+  void LogResidualHistograms() const ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
 
   // Updates the trajectory connectivity structure with a new constraint.
   void UpdateTrajectoryConnectivity(const Constraint& constraint)
-      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
 
   const proto::PoseGraphOptions options_;
   GlobalSlamOptimizationCallback global_slam_optimization_callback_;
+  RelocalizationResultCallback re_localization_result_callback_;
   mutable absl::Mutex mutex_;
   absl::Mutex work_queue_mutex_;
 
   // If it exists, further work items must be added to this queue, and will be
   // considered later.
-  std::unique_ptr<WorkQueue> work_queue_ GUARDED_BY(work_queue_mutex_);
+  std::unique_ptr<WorkQueue> work_queue_ ABSL_GUARDED_BY(work_queue_mutex_);
 
   // We globally localize a fraction of the nodes from each trajectory.
   absl::flat_hash_map<int, std::unique_ptr<common::FixedRatioSampler>>
-      global_localization_samplers_ GUARDED_BY(mutex_);
+      global_localization_samplers_ ABSL_GUARDED_BY(mutex_);
 
   // Number of nodes added since last loop closure.
-  int num_nodes_since_last_loop_closure_ GUARDED_BY(mutex_) = 0;
+  int num_nodes_since_last_loop_closure_ ABSL_GUARDED_BY(mutex_) = 0;
 
   // Current optimization problem.
   std::unique_ptr<optimization::OptimizationProblem3D> optimization_problem_;
@@ -264,9 +271,10 @@ class PoseGraph3D : public PoseGraph {
   common::ThreadPool* const thread_pool_;
 
   // List of all trimmers to consult when optimizations finish.
-  std::vector<std::unique_ptr<PoseGraphTrimmer>> trimmers_ GUARDED_BY(mutex_);
+  std::vector<std::unique_ptr<PoseGraphTrimmer>> trimmers_ ABSL_GUARDED_BY(mutex_);
 
-  PoseGraphData data_ GUARDED_BY(mutex_);
+  PoseGraphData data_ ABSL_GUARDED_BY(mutex_);
+  std::unordered_map<int, TrajectoryMode> trajectories_mode_;
 
   // Allows querying and manipulating the pose graph by the 'trimmers_'. The
   // 'mutex_' of the pose graph is held while this class is used.
@@ -278,18 +286,18 @@ class PoseGraph3D : public PoseGraph {
     int num_submaps(int trajectory_id) const override;
     std::vector<SubmapId> GetSubmapIds(int trajectory_id) const override;
     MapById<SubmapId, SubmapData> GetOptimizedSubmapData() const override
-        EXCLUSIVE_LOCKS_REQUIRED(parent_->mutex_);
+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(parent_->mutex_);
     const MapById<NodeId, TrajectoryNode>& GetTrajectoryNodes() const override
-        EXCLUSIVE_LOCKS_REQUIRED(parent_->mutex_);
+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(parent_->mutex_);
     const std::vector<Constraint>& GetConstraints() const override
-        EXCLUSIVE_LOCKS_REQUIRED(parent_->mutex_);
+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(parent_->mutex_);
     void TrimSubmap(const SubmapId& submap_id)
-        EXCLUSIVE_LOCKS_REQUIRED(parent_->mutex_) override;
+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(parent_->mutex_) override;
     bool IsFinished(int trajectory_id) const override
-        EXCLUSIVE_LOCKS_REQUIRED(parent_->mutex_);
+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(parent_->mutex_);
 
     void SetTrajectoryState(int trajectory_id, TrajectoryState state) override
-        EXCLUSIVE_LOCKS_REQUIRED(parent_->mutex_);
+        ABSL_EXCLUSIVE_LOCKS_REQUIRED(parent_->mutex_);
 
    private:
     PoseGraph3D* const parent_;
diff --git a/cartographer/mapping/internal/connected_components.h b/cartographer/mapping/internal/connected_components.h
index 05f327e..bc9cb69 100644
--- a/cartographer/mapping/internal/connected_components.h
+++ b/cartographer/mapping/internal/connected_components.h
@@ -41,45 +41,45 @@ class ConnectedComponents {
   ConnectedComponents& operator=(const ConnectedComponents&) = delete;
 
   // Add a trajectory which is initially connected to only itself.
-  void Add(int trajectory_id) LOCKS_EXCLUDED(lock_);
+  void Add(int trajectory_id) ABSL_LOCKS_EXCLUDED(lock_);
 
   // Connect two trajectories. If either trajectory is untracked, it will be
   // tracked. This function is invariant to the order of its arguments. Repeated
   // calls to Connect increment the connectivity count.
-  void Connect(int trajectory_id_a, int trajectory_id_b) LOCKS_EXCLUDED(lock_);
+  void Connect(int trajectory_id_a, int trajectory_id_b) ABSL_LOCKS_EXCLUDED(lock_);
 
   // Determines if two trajectories have been (transitively) connected. If
   // either trajectory is not being tracked, returns false, except when it is
   // the same trajectory, where it returns true. This function is invariant to
   // the order of its arguments.
   bool TransitivelyConnected(int trajectory_id_a, int trajectory_id_b)
-      LOCKS_EXCLUDED(lock_);
+      ABSL_LOCKS_EXCLUDED(lock_);
 
   // Return the number of _direct_ connections between 'trajectory_id_a' and
   // 'trajectory_id_b'. If either trajectory is not being tracked, returns 0.
   // This function is invariant to the order of its arguments.
   int ConnectionCount(int trajectory_id_a, int trajectory_id_b)
-      LOCKS_EXCLUDED(lock_);
+      ABSL_LOCKS_EXCLUDED(lock_);
 
   // The trajectory IDs, grouped by connectivity.
-  std::vector<std::vector<int>> Components() LOCKS_EXCLUDED(lock_);
+  std::vector<std::vector<int>> Components() ABSL_LOCKS_EXCLUDED(lock_);
 
   // The list of trajectory IDs that belong to the same connected component as
   // 'trajectory_id'.
-  std::vector<int> GetComponent(int trajectory_id) LOCKS_EXCLUDED(lock_);
+  std::vector<int> GetComponent(int trajectory_id) ABSL_LOCKS_EXCLUDED(lock_);
 
  private:
   // Find the representative and compresses the path to it.
-  int FindSet(int trajectory_id) EXCLUSIVE_LOCKS_REQUIRED(lock_);
+  int FindSet(int trajectory_id) ABSL_EXCLUSIVE_LOCKS_REQUIRED(lock_);
   void Union(int trajectory_id_a, int trajectory_id_b)
-      EXCLUSIVE_LOCKS_REQUIRED(lock_);
+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(lock_);
 
   absl::Mutex lock_;
   // Tracks transitive connectivity using a disjoint set forest, i.e. each
   // entry points towards the representative for the given trajectory.
-  std::map<int, int> forest_ GUARDED_BY(lock_);
+  std::map<int, int> forest_ ABSL_GUARDED_BY(lock_);
   // Tracks the number of direct connections between a pair of trajectories.
-  std::map<std::pair<int, int>, int> connection_map_ GUARDED_BY(lock_);
+  std::map<std::pair<int, int>, int> connection_map_ ABSL_GUARDED_BY(lock_);
 };
 
 // Returns a proto encoding connected components.
diff --git a/cartographer/mapping/internal/constraints/constraint_builder_2d.cc b/cartographer/mapping/internal/constraints/constraint_builder_2d.cc
index ad3dfb7..32c88a4 100644
--- a/cartographer/mapping/internal/constraints/constraint_builder_2d.cc
+++ b/cartographer/mapping/internal/constraints/constraint_builder_2d.cc
@@ -100,7 +100,7 @@ void ConstraintBuilder2D::MaybeAddConstraint(
   const auto* scan_matcher =
       DispatchScanMatcherConstruction(submap_id, submap->grid());
   auto constraint_task = absl::make_unique<common::Task>();
-  constraint_task->SetWorkItem([=]() LOCKS_EXCLUDED(mutex_) {
+  constraint_task->SetWorkItem([=]() ABSL_LOCKS_EXCLUDED(mutex_) {
     ComputeConstraint(submap_id, submap, node_id, false, /* match_full_submap */
                       constant_data, initial_relative_pose, *scan_matcher,
                       constraint);
@@ -125,7 +125,7 @@ void ConstraintBuilder2D::MaybeAddGlobalConstraint(
   const auto* scan_matcher =
       DispatchScanMatcherConstruction(submap_id, submap->grid());
   auto constraint_task = absl::make_unique<common::Task>();
-  constraint_task->SetWorkItem([=]() LOCKS_EXCLUDED(mutex_) {
+  constraint_task->SetWorkItem([=]() ABSL_LOCKS_EXCLUDED(mutex_) {
     ComputeConstraint(submap_id, submap, node_id, true, /* match_full_submap */
                       constant_data, transform::Rigid2d::Identity(),
                       *scan_matcher, constraint);
diff --git a/cartographer/mapping/internal/constraints/constraint_builder_2d.h b/cartographer/mapping/internal/constraints/constraint_builder_2d.h
index 6667fdb..b61f64c 100644
--- a/cartographer/mapping/internal/constraints/constraint_builder_2d.h
+++ b/cartographer/mapping/internal/constraints/constraint_builder_2d.h
@@ -118,7 +118,7 @@ class ConstraintBuilder2D {
   // accessed after 'creation_task_handle' has completed.
   const SubmapScanMatcher* DispatchScanMatcherConstruction(
       const SubmapId& submap_id, const Grid2D* grid)
-      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
 
   // Runs in a background thread and does computations for an additional
   // constraint, assuming 'submap' and 'compressed_point_cloud' do not change
@@ -129,9 +129,9 @@ class ConstraintBuilder2D {
                          const transform::Rigid2d& initial_relative_pose,
                          const SubmapScanMatcher& submap_scan_matcher,
                          std::unique_ptr<Constraint>* constraint)
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
 
-  void RunWhenDoneCallback() LOCKS_EXCLUDED(mutex_);
+  void RunWhenDoneCallback() ABSL_LOCKS_EXCLUDED(mutex_);
 
   const constraints::proto::ConstraintBuilderOptions options_;
   common::ThreadPoolInterface* thread_pool_;
@@ -139,34 +139,34 @@ class ConstraintBuilder2D {
 
   // 'callback' set by WhenDone().
   std::unique_ptr<std::function<void(const Result&)>> when_done_
-      GUARDED_BY(mutex_);
+      ABSL_GUARDED_BY(mutex_);
 
   // TODO(gaschler): Use atomics instead of mutex to access these counters.
   // Number of the node in reaction to which computations are currently
   // added. This is always the number of nodes seen so far, even when older
   // nodes are matched against a new submap.
-  int num_started_nodes_ GUARDED_BY(mutex_) = 0;
+  int num_started_nodes_ ABSL_GUARDED_BY(mutex_) = 0;
 
-  int num_finished_nodes_ GUARDED_BY(mutex_) = 0;
+  int num_finished_nodes_ ABSL_GUARDED_BY(mutex_) = 0;
 
-  std::unique_ptr<common::Task> finish_node_task_ GUARDED_BY(mutex_);
+  std::unique_ptr<common::Task> finish_node_task_ ABSL_GUARDED_BY(mutex_);
 
-  std::unique_ptr<common::Task> when_done_task_ GUARDED_BY(mutex_);
+  std::unique_ptr<common::Task> when_done_task_ ABSL_GUARDED_BY(mutex_);
 
   // Constraints currently being computed in the background. A deque is used to
   // keep pointers valid when adding more entries. Constraint search results
   // with below-threshold scores are also 'nullptr'.
-  std::deque<std::unique_ptr<Constraint>> constraints_ GUARDED_BY(mutex_);
+  std::deque<std::unique_ptr<Constraint>> constraints_ ABSL_GUARDED_BY(mutex_);
 
   // Map of dispatched or constructed scan matchers by 'submap_id'.
   std::map<SubmapId, SubmapScanMatcher> submap_scan_matchers_
-      GUARDED_BY(mutex_);
+      ABSL_GUARDED_BY(mutex_);
   std::map<SubmapId, common::FixedRatioSampler> per_submap_sampler_;
 
   scan_matching::CeresScanMatcher2D ceres_scan_matcher_;
 
   // Histogram of scan matcher scores.
-  common::Histogram score_histogram_ GUARDED_BY(mutex_);
+  common::Histogram score_histogram_ ABSL_GUARDED_BY(mutex_);
 };
 
 }  // namespace constraints
diff --git a/cartographer/mapping/internal/constraints/constraint_builder_3d.cc b/cartographer/mapping/internal/constraints/constraint_builder_3d.cc
index 87b3742..5b46179 100644
--- a/cartographer/mapping/internal/constraints/constraint_builder_3d.cc
+++ b/cartographer/mapping/internal/constraints/constraint_builder_3d.cc
@@ -102,7 +102,7 @@ void ConstraintBuilder3D::MaybeAddConstraint(
   auto* const constraint = &constraints_.back();
   const auto* scan_matcher = DispatchScanMatcherConstruction(submap_id, submap);
   auto constraint_task = absl::make_unique<common::Task>();
-  constraint_task->SetWorkItem([=]() LOCKS_EXCLUDED(mutex_) {
+  constraint_task->SetWorkItem([=]() ABSL_LOCKS_EXCLUDED(mutex_) {
     ComputeConstraint(submap_id, node_id, false, /* match_full_submap */
                       constant_data, global_node_pose, global_submap_pose,
                       *scan_matcher, constraint);
@@ -128,7 +128,7 @@ void ConstraintBuilder3D::MaybeAddGlobalConstraint(
   auto* const constraint = &constraints_.back();
   const auto* scan_matcher = DispatchScanMatcherConstruction(submap_id, submap);
   auto constraint_task = absl::make_unique<common::Task>();
-  constraint_task->SetWorkItem([=]() LOCKS_EXCLUDED(mutex_) {
+  constraint_task->SetWorkItem([=]() ABSL_LOCKS_EXCLUDED(mutex_) {
     ComputeConstraint(submap_id, node_id, true, /* match_full_submap */
                       constant_data,
                       transform::Rigid3d::Rotation(global_node_rotation),
diff --git a/cartographer/mapping/internal/constraints/constraint_builder_3d.h b/cartographer/mapping/internal/constraints/constraint_builder_3d.h
index 247a9da..8005ccc 100644
--- a/cartographer/mapping/internal/constraints/constraint_builder_3d.h
+++ b/cartographer/mapping/internal/constraints/constraint_builder_3d.h
@@ -126,7 +126,7 @@ class ConstraintBuilder3D {
   // accessed after 'creation_task_handle' has completed.
   const SubmapScanMatcher* DispatchScanMatcherConstruction(
       const SubmapId& submap_id, const Submap3D* submap)
-      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mutex_);
 
   // Runs in a background thread and does computations for an additional
   // constraint.
@@ -138,9 +138,9 @@ class ConstraintBuilder3D {
                          const transform::Rigid3d& global_submap_pose,
                          const SubmapScanMatcher& submap_scan_matcher,
                          std::unique_ptr<Constraint>* constraint)
-      LOCKS_EXCLUDED(mutex_);
+      ABSL_LOCKS_EXCLUDED(mutex_);
 
-  void RunWhenDoneCallback() LOCKS_EXCLUDED(mutex_);
+  void RunWhenDoneCallback() ABSL_LOCKS_EXCLUDED(mutex_);
 
   const proto::ConstraintBuilderOptions options_;
   common::ThreadPoolInterface* thread_pool_;
@@ -148,36 +148,36 @@ class ConstraintBuilder3D {
 
   // 'callback' set by WhenDone().
   std::unique_ptr<std::function<void(const Result&)>> when_done_
-      GUARDED_BY(mutex_);
+      ABSL_GUARDED_BY(mutex_);
 
   // TODO(gaschler): Use atomics instead of mutex to access these counters.
   // Number of the node in reaction to which computations are currently
   // added. This is always the number of nodes seen so far, even when older
   // nodes are matched against a new submap.
-  int num_started_nodes_ GUARDED_BY(mutex_) = 0;
+  int num_started_nodes_ ABSL_GUARDED_BY(mutex_) = 0;
 
-  int num_finished_nodes_ GUARDED_BY(mutex_) = 0;
+  int num_finished_nodes_ ABSL_GUARDED_BY(mutex_) = 0;
 
-  std::unique_ptr<common::Task> finish_node_task_ GUARDED_BY(mutex_);
+  std::unique_ptr<common::Task> finish_node_task_ ABSL_GUARDED_BY(mutex_);
 
-  std::unique_ptr<common::Task> when_done_task_ GUARDED_BY(mutex_);
+  std::unique_ptr<common::Task> when_done_task_ ABSL_GUARDED_BY(mutex_);
 
   // Constraints currently being computed in the background. A deque is used to
   // keep pointers valid when adding more entries. Constraint search results
   // with below-threshold scores are also 'nullptr'.
-  std::deque<std::unique_ptr<Constraint>> constraints_ GUARDED_BY(mutex_);
+  std::deque<std::unique_ptr<Constraint>> constraints_ ABSL_GUARDED_BY(mutex_);
 
   // Map of dispatched or constructed scan matchers by 'submap_id'.
   std::map<SubmapId, SubmapScanMatcher> submap_scan_matchers_
-      GUARDED_BY(mutex_);
+      ABSL_GUARDED_BY(mutex_);
   std::map<SubmapId, common::FixedRatioSampler> per_submap_sampler_;
 
   scan_matching::CeresScanMatcher3D ceres_scan_matcher_;
 
   // Histograms of scan matcher scores.
-  common::Histogram score_histogram_ GUARDED_BY(mutex_);
-  common::Histogram rotational_score_histogram_ GUARDED_BY(mutex_);
-  common::Histogram low_resolution_score_histogram_ GUARDED_BY(mutex_);
+  common::Histogram score_histogram_ ABSL_GUARDED_BY(mutex_);
+  common::Histogram rotational_score_histogram_ ABSL_GUARDED_BY(mutex_);
+  common::Histogram low_resolution_score_histogram_ ABSL_GUARDED_BY(mutex_);
 };
 
 }  // namespace constraints
diff --git a/cartographer/mapping/map_builder.cc b/cartographer/mapping/map_builder.cc
index ba8a8b7..722ea25 100644
--- a/cartographer/mapping/map_builder.cc
+++ b/cartographer/mapping/map_builder.cc
@@ -41,7 +41,7 @@ namespace mapping {
 namespace {
 
 using mapping::proto::SerializedData;
-
+using mapping::PoseGraphInterface;
 std::vector<std::string> SelectRangeSensorIds(
     const std::set<MapBuilder::SensorId>& expected_sensor_ids) {
   std::vector<std::string> range_sensor_ids;
@@ -72,6 +72,18 @@ void MaybeAddPureLocalizationTrimmer(
   }
 }
 
+void MaybeSetRelocalizationCallback(
+    PoseGraphInterface::RelocalizationResultCallback relocalization_callback,
+    const proto::TrajectoryBuilderOptions& trajectory_options,
+    PoseGraph* pose_graph) {
+  if (!trajectory_options.pure_localization() &&
+      !trajectory_options.has_pure_localization_trimmer()) {
+    return;
+  }
+  if (relocalization_callback) {
+     pose_graph->SetReLocalizationResultCallback(relocalization_callback);
+  }
+}
 }  // namespace
 
 MapBuilder::MapBuilder(const proto::MapBuilderOptions& options)
@@ -99,10 +111,26 @@ MapBuilder::MapBuilder(const proto::MapBuilderOptions& options)
   }
 }
 
+void MapBuilder::SetTrajectoryModeWithOption(
+      const int trajectory_id,
+      const proto::TrajectoryBuilderOptions& trajectory_options) {
+  if (trajectory_options.pure_localization() ||
+      trajectory_options.has_pure_localization_trimmer()) {
+    SetTrajectoryMode(trajectory_id, TrajectoryMode::LOCALIZATION);
+  } else {
+    SetTrajectoryMode(trajectory_id, TrajectoryMode::MAPPING);
+  }
+}
+
+void MapBuilder::SetTrajectoryMode(int trajectory_id, TrajectoryMode mode) {
+  pose_graph_->SetTrajectoryMode(trajectory_id, mode);
+}
+
 int MapBuilder::AddTrajectoryBuilder(
     const std::set<SensorId>& expected_sensor_ids,
     const proto::TrajectoryBuilderOptions& trajectory_options,
-    LocalSlamResultCallback local_slam_result_callback) {
+    LocalSlamResultCallback local_slam_result_callback,
+    ReLocalizationCallback relocalization_callback) {
   const int trajectory_id = trajectory_builders_.size();
 
   absl::optional<MotionFilter> pose_graph_odometry_motion_filter;
@@ -145,6 +173,9 @@ int MapBuilder::AddTrajectoryBuilder(
   }
   MaybeAddPureLocalizationTrimmer(trajectory_id, trajectory_options,
                                   pose_graph_.get());
+  MaybeSetRelocalizationCallback(relocalization_callback, trajectory_options,
+                                 pose_graph_.get());
+  SetTrajectoryModeWithOption(trajectory_id, trajectory_options);
 
   if (trajectory_options.has_initial_trajectory_pose()) {
     const auto& initial_trajectory_pose =
@@ -380,6 +411,10 @@ std::map<int, int> MapBuilder::LoadState(
         FromProto(pose_graph_proto.constraint()));
   }
   CHECK(reader->eof());
+  for (const auto remapping_id : trajectory_remapping) {
+    // set new trajectory id load from proto to PREVIOUS_MAP Mode
+    SetTrajectoryMode(remapping_id.second, TrajectoryMode::PREVIOUS_MAP);
+  }
   return trajectory_remapping;
 }
 
diff --git a/cartographer/mapping/map_builder.h b/cartographer/mapping/map_builder.h
index ee885a0..78f067e 100644
--- a/cartographer/mapping/map_builder.h
+++ b/cartographer/mapping/map_builder.h
@@ -41,7 +41,8 @@ class MapBuilder : public MapBuilderInterface {
   int AddTrajectoryBuilder(
       const std::set<SensorId> &expected_sensor_ids,
       const proto::TrajectoryBuilderOptions &trajectory_options,
-      LocalSlamResultCallback local_slam_result_callback) override;
+      LocalSlamResultCallback local_slam_result_callback,
+      ReLocalizationCallback relocalization_callback = nullptr) override;
 
   int AddTrajectoryForDeserialization(
       const proto::TrajectoryBuilderOptionsWithSensorIds
@@ -82,6 +83,17 @@ class MapBuilder : public MapBuilderInterface {
     return all_trajectory_builder_options_;
   }
 
+  const std::unordered_map<int, TrajectoryMode>
+      &GetAllTrajectoryMode() const override {
+    return pose_graph_->GetAllTrajectoryMode();
+  }
+
+  void SetTrajectoryModeWithOption(
+      const int trajectory_id,
+      const proto::TrajectoryBuilderOptions& trajectory_options) override;
+
+  void SetTrajectoryMode(int trajectory_id, TrajectoryMode mode) override;
+
  private:
   const proto::MapBuilderOptions options_;
   common::ThreadPool thread_pool_;
diff --git a/cartographer/mapping/map_builder_interface.h b/cartographer/mapping/map_builder_interface.h
index 76062fb..6b0c704 100644
--- a/cartographer/mapping/map_builder_interface.h
+++ b/cartographer/mapping/map_builder_interface.h
@@ -45,9 +45,10 @@ class MapBuilderInterface {
  public:
   using LocalSlamResultCallback =
       TrajectoryBuilderInterface::LocalSlamResultCallback;
-
+  using ReLocalizationCallback =
+      PoseGraphInterface::RelocalizationResultCallback;
   using SensorId = TrajectoryBuilderInterface::SensorId;
-
+  using TrajectoryMode = PoseGraphInterface::TrajectoryMode;
   MapBuilderInterface() {}
   virtual ~MapBuilderInterface() {}
 
@@ -58,7 +59,8 @@ class MapBuilderInterface {
   virtual int AddTrajectoryBuilder(
       const std::set<SensorId>& expected_sensor_ids,
       const proto::TrajectoryBuilderOptions& trajectory_options,
-      LocalSlamResultCallback local_slam_result_callback) = 0;
+      LocalSlamResultCallback local_slam_result_callback,
+      ReLocalizationCallback relocalization_callback = nullptr) = 0;
 
   // Creates a new trajectory and returns its index. Querying the trajectory
   // builder for it will return 'nullptr'.
@@ -112,6 +114,12 @@ class MapBuilderInterface {
 
   virtual const std::vector<proto::TrajectoryBuilderOptionsWithSensorIds>&
   GetAllTrajectoryBuilderOptions() const = 0;
+  virtual void SetTrajectoryModeWithOption(
+      const int trajectory_id,
+      const proto::TrajectoryBuilderOptions& trajectory_options) = 0;
+  virtual void SetTrajectoryMode(int trajectory_id, TrajectoryMode mode) = 0;
+  virtual const std::unordered_map<int, TrajectoryMode>&
+  GetAllTrajectoryMode() const = 0;
 };
 
 }  // namespace mapping
diff --git a/cartographer/mapping/pose_graph.h b/cartographer/mapping/pose_graph.h
index b4dfd3b..c164e84 100644
--- a/cartographer/mapping/pose_graph.h
+++ b/cartographer/mapping/pose_graph.h
@@ -128,6 +128,9 @@ class PoseGraph : public PoseGraphInterface {
   virtual std::map<std::string /* landmark ID */, PoseGraph::LandmarkNode>
   GetLandmarkNodes() const = 0;
 
+  virtual const std::unordered_map<int, TrajectoryMode>&
+  GetAllTrajectoryMode() const = 0;
+  virtual void SetTrajectoryMode(const int trajectory_id, const TrajectoryMode mode) = 0;
   // Sets a relative initial pose 'relative_pose' for 'from_trajectory_id' with
   // respect to 'to_trajectory_id' at time 'time'.
   virtual void SetInitialTrajectoryPose(int from_trajectory_id,
diff --git a/cartographer/mapping/pose_graph_interface.h b/cartographer/mapping/pose_graph_interface.h
index 68551f1..b35473e 100644
--- a/cartographer/mapping/pose_graph_interface.h
+++ b/cartographer/mapping/pose_graph_interface.h
@@ -82,11 +82,14 @@ class PoseGraphInterface {
   };
 
   enum class TrajectoryState { ACTIVE, FINISHED, FROZEN, DELETED };
+  enum class TrajectoryMode { MAPPING, LOCALIZATION, PREVIOUS_MAP };
 
   using GlobalSlamOptimizationCallback =
       std::function<void(const std::map<int /* trajectory_id */, SubmapId>&,
                          const std::map<int /* trajectory_id */, NodeId>&)>;
-
+  using RelocalizationResultCallback =
+      std::function<void(const std::map<int /* trajectory_id */, common::Time>&,
+                         const std::map<int /* trajectory_id */, std::vector<int>>&)>;
   PoseGraphInterface() {}
   virtual ~PoseGraphInterface() {}
 
@@ -157,6 +160,8 @@ class PoseGraphInterface {
   // problem is solved.
   virtual void SetGlobalSlamOptimizationCallback(
       GlobalSlamOptimizationCallback callback) = 0;
+  virtual void SetReLocalizationResultCallback(
+      RelocalizationResultCallback callback) = 0;
 };
 
 }  // namespace mapping
diff --git a/cartographer/transform/rigid_transform.h b/cartographer/transform/rigid_transform.h
index 0823037..b26aea0 100644
--- a/cartographer/transform/rigid_transform.h
+++ b/cartographer/transform/rigid_transform.h
@@ -169,6 +169,12 @@ class Rigid3 {
                             rotation().y(), rotation().z());
   }
 
+  std::string DebugStringForEvaluation() const {
+    return absl::Substitute("$0 $1 $2 $3 $4 $5 $6\n",
+                            translation().x(), translation().y(),
+                            translation().z(), rotation().x(),
+                            rotation().y(), rotation().z(), rotation().w());
+  }
   bool IsValid() const {
     return !std::isnan(translation_.x()) && !std::isnan(translation_.y()) &&
            !std::isnan(translation_.z()) &&
diff --git a/cmake/functions.cmake b/cmake/functions.cmake
index cdbd896..fa265ca 100644
--- a/cmake/functions.cmake
+++ b/cmake/functions.cmake
@@ -91,7 +91,6 @@ macro(google_initialize_cartographer_project)
     google_add_flag(GOOG_CXX_FLAGS "-Werror=reorder")
     google_add_flag(GOOG_CXX_FLAGS "-Werror=return-type")
     google_add_flag(GOOG_CXX_FLAGS "-Werror=switch")
-    google_add_flag(GOOG_CXX_FLAGS "-Werror=uninitialized")
 
     if (CMAKE_CXX_COMPILER_ID MATCHES "Clang" OR CMAKE_CXX_COMPILER_ID MATCHES "AppleClang")
       google_add_flag(GOOG_CXX_FLAGS "-Wthread-safety")
diff --git a/cmake/modules/FindGMock.cmake b/cmake/modules/FindGMock.cmake
index b29c0fe..c57015e 100644
--- a/cmake/modules/FindGMock.cmake
+++ b/cmake/modules/FindGMock.cmake
@@ -20,6 +20,14 @@ if(NOT GMock_FOUND)
     PATHS
       /usr
   )
+  find_library(GTEST_LIBRARIES
+    NAMES gtest
+    PATH_SUFFIXES lib
+  )
+  find_library(GMOCK_A_LIBRARIES
+    NAMES gmock
+    PATH_SUFFIXES lib
+  )
 
   # Find system-wide installed gmock.
   find_library(GMOCK_LIBRARIES
@@ -83,7 +91,7 @@ if(NOT GMock_FOUND)
 
   # System-wide installed gmock library might require pthreads.
   find_package(Threads REQUIRED)
-  list(APPEND GMOCK_LIBRARIES ${CMAKE_THREAD_LIBS_INIT})
+  list(APPEND GMOCK_LIBRARIES ${GMOCK_A_LIBRARIES} ${GTEST_LIBRARIES} ${CMAKE_THREAD_LIBS_INIT})
 endif()
 
 include(FindPackageHandleStandardArgs)
diff --git a/cmake/modules/FindLuaGoogle.cmake b/cmake/modules/FindLuaGoogle.cmake
index c76b8cc..b7d5a2d 100644
--- a/cmake/modules/FindLuaGoogle.cmake
+++ b/cmake/modules/FindLuaGoogle.cmake
@@ -70,7 +70,7 @@ unset(_lua_append_versions)
 
 # this is a function only to have all the variables inside go away automatically
 function(_lua_set_version_vars)
-    set(LUA_VERSIONS5 5.3 5.2)
+    set(LUA_VERSIONS5 5.4 5.3 5.2)
 
     if (Lua_FIND_VERSION_EXACT)
         if (Lua_FIND_VERSION_COUNT GREATER 1)
@@ -199,7 +199,7 @@ if (LUA_LIBRARY)
     # include the math library for Unix
     if (UNIX AND NOT APPLE AND NOT BEOS)
         find_library(LUA_MATH_LIBRARY m)
-        set(LUA_LIBRARIES "${LUA_LIBRARY};${LUA_MATH_LIBRARY}")
+        set(LUA_LIBRARIES "${LUA_LIBRARY};${LUA_MATH_LIBRARY};dl")
     # For Windows and Mac, don't need to explicitly include the math library
     else ()
         set(LUA_LIBRARIES "${LUA_LIBRARY}")
-- 
2.41.0.windows.3

